<!--markdown-->EIGRP协议包含以下4个部件：
- 依赖于协议的模块；
- 可靠传输协议（RTP）；
- 邻居发现和恢复；
- 扩散更新算法（DUAL）。

## EIGRP的度量

metric=256×{\\[**K1**×BW<sub>IGRP(min)</sub>＋(**K2**×BW<sub>IGRP(min)</sub>)／(256－LOAD)＋**K3**×DLY<sub>IGRP(sum)</sub>]×\\[**K5**／(RELIABILITY＋**K4**)]}

BW<sub>IGRP(min)</sub>是沿着路由路径到达目的网络的所有出站接口的带宽中的最小值，是用10<sup>7</sup>/BW（带宽）得来的。如果接口的带宽是1544 kbit/s，那么BW<sub>IGRP(min)</sub>=10<sup>7</sup>/1544=6476。

而DLY<sub>IGRP(sum)</sub>是这条路由路径时延的总和。是以10us作为单位。如果接口的DLY值是50，那么DLY<sub>IGRP(sum)</sub>=DLY/10=50/10=5。

可靠性和负载是基于5分钟时间常数的指数加权平均计算的，它们每5秒被更新一次。

系数K1到K5是可配置的加权值，它们的缺省值是：K1=K3=1，K2=K4=K5=0。这些值可以通过下面的命令来更改：

        metric weights tos K1 K2 K3 K4 K5

tos的值恒为0。

使用K1～K5的缺省值，EIGRP的复合度量的计算公式可以简化为：metirc=256×(BW<sub>IGRP(min)</sub>+DLY<sub>IGRP(sum)</sub>)。

## 依赖于协议的模块

EIGRP协议实现了IP协议、IPX协议和AppleTalk协议的模块，它可以担负起某一特定协议的路由选择任务。例如，IPX EIGRP模块可以负责在IPX网络上与其他IPX EIGRP进程进行路由信息交换，并且将这些信息传递给DUAL。每个单独模块的通信量被封装在它们各自的网络层协议中。

## 可靠传输协议

可靠传输协议（Reliable Transport Protocol，RTP）用来管理EIGRP数据包的发送和接收。可靠的发送是指发送是有保障的而且数据包是有序的发送的。有保障的发送是依赖Cisco公司的“可靠组播（reliable multicast）”这个私有算法来实现的，它使用保留的D类地址224.0.0.10。每一个接收可靠组播数据包的邻居都会发送一个单播的确认数据包。

有序的发送是通过在每个数据包中包含的两个序列号来实现的。每一个数据包都包含一个由发送该数据包的路由器分配的序列号，这个序列号在每台路由器发送一个新的数据包时递增1.另外，发送路由器会把最近从目的路由器收到的数据包的序列号放在该数据包中。

在一些实例中，RTP也可以使用不可靠的发送，不需要确认，而且在使用不可靠发送的EIGRP数据包中不包含序列号。

EIGRP协议使用多种类型的数据包，所有这些数据包都通过IP头部的协议号88来标识。
- **Hello**  用于邻居发现和恢复进程。Hello数据包使用组播方式发送，而且使用不可靠的发送方式。
- **确认(Acknowledgments, ACK）**  是不包含数据的Hello数据包。ACK总是使用单播方式和不可靠的发送方式。
- **更新（Update）** 用于传递路由更新信息。不像RIP协议和IGRP协议的更新，EIGRP协议的这些更新数据包只在必要的时候传递必要的信息，而且仅仅传递给需要路由信息的路由器。当只有某一指定的路由器需要路由更新时，更新数据包就是单播发送的；当有多台路由器需要路由更新时，更新数据包就是组播发送的。更新数据包总是使用可靠的发送方式。
- **查询（Query）和答复（Reply）**  是DUAL有限状态机用来管理它的扩散计算的。查询消息可以使用组播方式或者单播方式发送，而回复消息总是单播方式发送的。查询和回复数据包都是使用可靠的发送方式。
- **请求（Request）**  最初打算提供给路由服务器使用的数据包类型，但是这个应用从来没有实现过，在一些老的文档中可能会提及它们。
 
如果任何数据包通过可靠的方式组播出去，而没有从邻居那里收到一个ACK数据包，那么这个数据包就会以单播方式被重新发送给那个没有响应的邻居。如果经过16次这样的单播重传还没有收到一个ACK数据包的话，那么这个邻居就会被宣告为无效。

在从组播方式切换到单播方式之前等待一个ACK时间可以由组播流计时器（multicast flow timer）指定。后续的单播之间的时间可以由重传超时（Retransmission Timeout，RTO）指定。组播流计时器和重传超时都可以通过平均回程时间（Smooth Round-Trip Time，SRTT）来计算。SRTT是一个用来衡量路由器发送EIGRP数据包到邻居和从邻居那里接收到该数据包的确认所花费的平均时间，以毫秒（ms）为单位。

## 邻居发现和恢复

因为EIGRP协议的更新消息是非周期的，因此有一个发现和跟踪邻居的方法是非常重要的。Hello数据包是以组播方式每5s发送一次的，其中减掉一个很小的随机时间用来防止更新的同步。在多点的X.25、帧中继和ATM接口上是以单播方式每60s发送一次的。Hello数据包都是不进行确认的。可以在每个接口上使用命令`ip hello-interval eigrp`更改hello数据包的时间间隔。

当一台路由器从它的邻居路由器收到一个Hello数据包时，这个数据包将包含一个抑制时间（hold time）。如果抵制计时器超时了，路由器还没收到后续的Hello数据包，那么将宣告这个邻居不可达，并且通知DUAL这个邻居丢失了。在缺省的情况下，抑制时间是Hello时间间隔的3倍，这个缺省值可以在接口上使用命令`ip hold-time eigrp`来更改。

## 扩散更新算法

扩散更新算法（Diffusing Update Algorithm，DUAL）是一个收敛算法。

### DUAL：术语和概念

1. **邻接（adjacency）**  刚启动时，路由器使用Hello数据包发现它的邻居并标识自己给邻居识别。当邻居被发现时，EIGRP协议将试图和它的邻居形成一个邻接关系。一旦邻接成功建立，路由器就可以从它们的邻居那里接收路由更新消息了。
2. **可行距离（Feasible Distance，FD）**  到达每一个目的地的最小度量将作为该目的地网络的可行距离。
3. **可行性条件（Feasibility Condition，FC）**  可行性条件就是需要满足下面这样的条件——本地路由器的一个邻居路由器所通告的到达一个目的网络的距离是否小于本地路由器到达相同目的网络的可行距离。
4. **可行后继路由器（Feasible Successor，FS**  如果本地路由器的邻居路由器所通告的到达目的网络的距离满足了FC，那么这个邻居就会成为该目的网络的一个可行后继路由器。
5. **后继路由器（successor）**  对于在拓扑结构表中列出的每一个目的网络，将选择拥有最小度量的路由并放置到路由表中。通告这条路由的邻居就成为一个后继路由器（也就是下一跳路由器）。

### DUAL有限状态机

当一个EIGRP路由器不执行扩散计算时，每一条路由都处于被动状态（passive state）。路由左边的关键字就是用来指出路由的被动状态的。

在产生输入事件（input event）的任何时，路由器都会重新评估一条路由的可行后继路由器的列表。一个输入事件可以是：

- 直连链路的代价发生变化；
- 直连链路的状态（up或down）发生变化；
- 收到一个更新数据包；
- 收到一个查询数据包；
- 收到一个答复数据包。

路由器重新评估的第一步是，**在本地路由器上执行一个本地计算（local computation）**，对所有的可行后继路由器重新计算到达目的地的距离。可能的结果有下面的一种或多种：

- 如果拥有最低的度量距离的可行后继路由器和已经存在的后继路由器不同，那么可行后继路由器将成为后继路由器；
- 如果新的度量距离小于FD，那么就更新FD；
- 如果新的度量距离和已经存在的度量距离不同，那么将向所有的邻居发送更新。

当路由器执行一个本地计算时，路由依然保持被动状态。**如果本地路由器发现了一台可行后继路由器**，那么将发送一个更新消息给它所有的邻居，但不改变路由的状态。

**如果没有发现任何一台可行后继路由器的话，那么路由器将开始进行扩散计算**，而且路由器的路由状态改变成活动状态（active state），路由的距离和FD也变为不可到达的了。在扩散计算完成和路由的状态返回到被动状态之前，路由器不能：

- 改变路由的后继路由器；
- 改变正在通告的路由的距离；
- 改变路由的FD；
- 开始进行路由的另一个扩散计算。
 
**路由器是通过向它所有的邻居发送查询来开始一个扩散计算的**，查询中包含一个到达目的地的新的本地路由器计算的距离。收到查询后，每一台邻居路由器将执行它自己的本地计算：

- 如果该邻居拥有到达目的地的一台或多台可行后继路由器，它将发送一个答复给原来发送查询的路由器。答复中将包含这台邻居路由器所计算的它到达目的网络的最小距离。
- 如果一个邻居没有可行后继路由器，它将把路由的状态改变为活动状态，并开始进行扩散计算。

当本地路由器收到所有发送到邻居路由器的查询的答复时，扩散计算就完成了。在扩散计算开始，会设置一个3分钟的活动计时器，如果计时超时后还没有收到所有的答复，那么这条路由就会被宣告卡在活动状态（Stuck-In-Active，SIA）。这些没有答复的邻居将从邻居表中删除，并且扩散计算认为这个邻居回应了一个无穷大的度量。在活动计时器超时之前，将保持路由状态为活动状态。可以通过`timers active-time`来改变或使其无效。	