-- MySQL dump 10.14  Distrib 5.5.64-MariaDB, for Linux (x86_64)
--
-- Host: localhost    Database: typecho
-- ------------------------------------------------------
-- Server version	5.5.64-MariaDB

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `typecho_comments`
--

DROP TABLE IF EXISTS `typecho_comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_comments` (
  `coid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `cid` int(10) unsigned DEFAULT '0',
  `created` int(10) unsigned DEFAULT '0',
  `author` varchar(200) DEFAULT NULL,
  `authorId` int(10) unsigned DEFAULT '0',
  `ownerId` int(10) unsigned DEFAULT '0',
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `ip` varchar(64) DEFAULT NULL,
  `agent` varchar(200) DEFAULT NULL,
  `text` text,
  `type` varchar(16) DEFAULT 'comment',
  `status` varchar(16) DEFAULT 'approved',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`coid`),
  KEY `cid` (`cid`),
  KEY `created` (`created`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_comments`
--

LOCK TABLES `typecho_comments` WRITE;
/*!40000 ALTER TABLE `typecho_comments` DISABLE KEYS */;
/*!40000 ALTER TABLE `typecho_comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_contents`
--

DROP TABLE IF EXISTS `typecho_contents`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_contents` (
  `cid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `modified` int(10) unsigned DEFAULT '0',
  `text` longtext,
  `order` int(10) unsigned DEFAULT '0',
  `authorId` int(10) unsigned DEFAULT '0',
  `template` varchar(32) DEFAULT NULL,
  `type` varchar(16) DEFAULT 'post',
  `status` varchar(16) DEFAULT 'publish',
  `password` varchar(32) DEFAULT NULL,
  `commentsNum` int(10) unsigned DEFAULT '0',
  `allowComment` char(1) DEFAULT '0',
  `allowPing` char(1) DEFAULT '0',
  `allowFeed` char(1) DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  `views` int(10) DEFAULT '0',
  PRIMARY KEY (`cid`),
  UNIQUE KEY `slug` (`slug`),
  KEY `created` (`created`)
) ENGINE=MyISAM AUTO_INCREMENT=60 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_contents`
--

LOCK TABLES `typecho_contents` WRITE;
/*!40000 ALTER TABLE `typecho_contents` DISABLE KEYS */;
INSERT INTO `typecho_contents` VALUES (1,'Linux系统管理','start',1503504000,1589620593,'<!--markdown-->参考网站：[Server World](https://www.server-world.info/en/)，需要翻墙。\r\n\r\n# 查看系统信息与日志\r\n\r\n`screenfetch`：查看系统信息\r\n\r\n`dmidecode`：查看系统信息\r\n\r\n`dmidecode -t memory `：查看内存信息\r\n\r\n`lsb_release -a`：查看系统信息\r\n\r\n`hostname -I`：查看主机的IP地址\r\n\r\n`ethtool eth0`：查看网卡的信息\r\n\r\n`fdisk`、`df`：查看硬盘信息\r\n\r\n**查看日志**\r\n\r\n`journalctl`: 系统日志\r\n\r\n`/var/log/secure`：安全信息、用户登陆日志\r\n\r\n`/var/log/cron` cron的日志路径\r\n\r\n`journalctl -u cron` 查看关于cron的日志\r\n\r\n**查看开机启动项**：\r\n\r\n`systemctl list-unit-files --type=service | grep enabled`\r\n\r\n**查看系统开机时各项服务的耗时**\r\n\r\n`systemd-analyze blame`\r\n\r\n**查看系统开机时间**\r\n\r\n`last reboot`\r\n\r\n`who -b`\r\n\r\n`who -r`\r\n\r\n**查处Apache服务是否开启**\r\n\r\n```sh\r\nsystemctl is-enabled httpd\r\n```\r\n\r\n**SELinux**\r\n\r\n`sestatus`：查看selinux状态\r\n\r\n`setenforce 0`：临时关闭selinux，重启后会再开启\r\n\r\n编辑`/etc/selinux/config`文件，设置`SELINUX=disabled`，重启后会永久关闭selinux\r\n\r\n参考：[Linux 系统开机启动项清理](http://blog.jobbole.com/112384/)\r\n\r\n**一些命令**：\r\n\r\n`visudo`：编辑sudo用户\r\n\r\n`dpkg -l | grep ^rc | awk \'{print $2}\' | xargs dpkg -P`：清理已经卸载了的包的配置信息\r\n\r\n[5个经典有趣的linux命令：带日期的history，测硬盘写入速度，查找最大的文件，获取文件的详细信息](http://www.codeceo.com/article/5-interest-linux-command-tips.html)\r\n\r\n`rename -n \"s/-.*//\" *`：批量前缀重命名\r\n\r\n`du -sh * | sort -n`：统计当前目录大小，并按大小排序\r\n\r\n**关于Linux的分区**\r\n\r\n`/`：根目录，根据我的经验，在只有“/”和\"home\"两个分区时，15G的根目录就满足个人日常使用。\r\n\r\n`/home`：用户家目录，建议单独分区\r\n\r\n`/opt`：可以存放自己安装的软件，建议单独分区\r\n\r\n##### systemd服务\r\n\r\nsystemd的服务分为`系统服务`和`用户服务`。\r\n\r\n系统服务的默认执行者是root，可以通过user=的方式指定其他用户。\r\n\r\n用户服务的执行者是用户，无法更改。\r\n\r\n#### awk命令\r\n\r\n使用`-F`参数改变分隔符，如：`awk -F \'-\'`。\r\n\r\n#### find命令 exec\r\n\r\n```sh\r\nfind / -type f -exec ls -l {} \\;\r\n```\r\n\r\n# 系统设置、系统管理\r\n\r\n**日期管理**\r\n\r\n```sh\r\ntimedatectl\r\n```\r\n\r\n**用户管理**\r\n\r\nusermod\r\n\r\n`useradd 用户名`：添加用户\r\n\r\n`passwd 用户名`：修改用户密码\r\n\r\n**把Debian家目录改为英文**:\r\n\r\n>编辑`.config/user-dirs.dirs`文件，把里面的路径改为英文，并新建英文目录即可\r\n\r\n**密钥管理**：\r\n\r\n>使用软件`seahorse`可以图形化管理密钥，另外命令`apt-key add file.asc`或`gpg --import file.asc`可以安装密钥\r\n\r\n**NetworkManager**：\r\n\r\n关闭NetworkManager的方法：编辑/etc/NetworkManager/NetworkManager.conf文件，把managerd的值改为false\r\n\r\n`nmcli`是它的CLI工具\r\n\r\n## 设置永久的IP地址\r\n\r\n### Ubuntu 18.04 LTS\r\n```\r\noot@dlp:~# vi /etc/netplan/01-netcfg.yaml\r\n\r\n# This file describes the network interfaces available on your system\r\n# For more information, see netplan(5).\r\nnetwork:\r\n  version: 2\r\n  renderer: networkd\r\n  ethernets:\r\n    ens3:\r\n      dhcp4: no\r\n      # IP address/subnet mask\r\n      addresses: [10.0.0.30/24]\r\n      # default gateway\r\n      gateway4: 10.0.0.1\r\n      nameservers:\r\n        # name server this host refers\r\n        addresses: [10.0.0.10,10.0.0.11]\r\n      dhcp6: no\r\n\r\n# apply settings\r\n\r\nroot@dlp:~# netplan apply\r\nroot@dlp:~# ip addr\r\n\r\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\r\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n    inet 127.0.0.1/8 scope host lo\r\n       valid_lft forever preferred_lft forever\r\n    inet6 ::1/128 scope host\r\n       valid_lft forever preferred_lft forever\r\n2: ens3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000\r\n    link/ether 52:54:00:19:e8:09 brd ff:ff:ff:ff:ff:ff\r\n    inet 10.0.0.30/24 brd 10.0.0.255 scope global ens3\r\n       valid_lft forever preferred_lft forever\r\n    inet6 fe80::5054:ff:fe19:e809/64 scope link\r\n       valid_lft forever preferred_lft forever\r\n```\r\n### Debian 10\r\n```\r\n root@dlp:~# vi /etc/network/interfaces\r\n\r\n# This file describes the network interfaces available on your system\r\n# and how to activate them. For more information, see interfaces(5).\r\n\r\nsource /etc/network/interfaces.d/*\r\n\r\n# The loopback network interface\r\nauto lo\r\niface lo inet loopback\r\n\r\n# The primary network interface\r\nallow-hotplug ens2\r\n# comment out\r\n#iface ens2 inet dhcp\r\n\r\n# add static settings\r\niface ens2 inet static\r\n# IP address\r\naddress 10.0.0.30\r\n# network address\r\nnetwork 10.0.0.0\r\n# subnet mask\r\nnetmask 255.255.255.0\r\n# broadcast address\r\nbroadcast 10.0.0.255\r\n# default gateway\r\ngateway 10.0.0.1\r\n# name server\r\ndns-nameservers 10.0.0.10\r\n\r\nroot@dlp:~# systemctl restart networking ifup@ens2\r\nroot@dlp:~# ip addr\r\n\r\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\r\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n    inet 127.0.0.1/8 scope host lo\r\n       valid_lft forever preferred_lft forever\r\n    inet6 ::1/128 scope host\r\n       valid_lft forever preferred_lft forever\r\n2: ens2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\r\n    link/ether 52:54:00:87:3e:e4 brd ff:ff:ff:ff:ff:ff\r\n    inet 10.0.0.30/24 brd 10.0.0.255 scope global ens2\r\n       valid_lft forever preferred_lft forever\r\n    inet6 fe80::5054:ff:fe87:3ee4/64 scope link\r\n       valid_lft forever preferred_lft forever\r\n```\r\n### CentOS 8\r\n```\r\n # if you did not set Host Name during installation, set it like follows\r\n\r\n[root@localhost ~]# hostnamectl set-hostname dlp.srv.world\r\n# display devices\r\n\r\n[root@localhost ~]# nmcli device\r\n\r\nDEVICE  TYPE      STATE      CONNECTION\r\nens2    ethernet  connected  ens2\r\nlo      loopback  unmanaged  --\r\n\r\n# set IPv4 address\r\n\r\n[root@localhost ~]# nmcli connection modify ens2 ipv4.addresses 10.0.0.30/24\r\n\r\n# set gateway\r\n\r\n[root@localhost ~]# nmcli connection modify ens2 ipv4.gateway 10.0.0.1\r\n\r\n# set DNS\r\n\r\n[root@localhost ~]# nmcli connection modify ens2 ipv4.dns 10.0.0.1\r\n\r\n# set manual for static setting (it\'s [auto] for DHCP)\r\n\r\n[root@localhost ~]# nmcli connection modify ens2 ipv4.method manual\r\n\r\n# restart the interface to reload settings\r\n\r\n[root@localhost ~]# nmcli connection down ens2; nmcli connection up ens2\r\n\r\nConnection \'ens2\' successfully deactivated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/1)\r\nConnection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/2)\r\n\r\n# show settings\r\n\r\n[root@localhost ~]# nmcli device show ens2\r\n\r\nGENERAL.DEVICE:                         ens2\r\nGENERAL.TYPE:                           ethernet\r\nGENERAL.HWADDR:                         52:54:00:D0:8F:0B\r\nGENERAL.MTU:                            1500\r\nGENERAL.STATE:                          100 (connected)\r\nGENERAL.CONNECTION:                     ens2\r\nGENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveC>\r\nWIRED-PROPERTIES.CARRIER:               on\r\nIP4.ADDRESS[1]:                         10.0.0.30/24\r\nIP4.GATEWAY:                            10.0.0.1\r\nIP4.ROUTE[1]:                           dst = 10.0.0.0/24, nh = 0.0.0.0, mt = 1>\r\nIP4.ROUTE[2]:                           dst = 0.0.0.0/0, nh = 10.0.0.1, mt = 100\r\nIP4.DNS[1]:                             10.0.0.10\r\nIP6.ADDRESS[1]:                         fe80::5054:ff:fed0:8f0b/64\r\nIP6.GATEWAY:                            --\r\nIP6.ROUTE[1]:                           dst = fe80::/64, nh = ::, mt = 100\r\nIP6.ROUTE[2]:                           dst = ff00::/8, nh = ::, mt = 256, tabl>\r\n\r\n# show state\r\n\r\n[root@localhost ~]# ip addr show\r\n\r\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\r\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\r\n    inet 127.0.0.1/8 scope host lo\r\n       valid_lft forever preferred_lft forever\r\n    inet6 ::1/128 scope host\r\n       valid_lft forever preferred_lft forever\r\n2: ens2: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000\r\n    link/ether 52:54:00:d0:8f:0b brd ff:ff:ff:ff:ff:ff\r\n    inet 10.0.0.30/24 brd 10.0.0.255 scope global noprefixroute ens2\r\n       valid_lft forever preferred_lft forever\r\n    inet6 fe80::5054:ff:fed0:8f0b/64 scope link noprefixroute\r\n       valid_lft forever preferred_lft forever\r\n```\r\n## 使用ifconfig设置临时IP地址\r\n\r\n`ifconfig eth0 192.168.0.2 netmask 255.255.255.0` 设置IP地址和掩码\r\n\r\n`route add default gw 192.168.0.1` 设置网关\r\n\r\n使用这个方法设置的IP和网关是临时的，重启后就会失效。\r\n\r\n# shell脚本\r\n\r\n**变量自增**\r\n\r\n    a=1\r\n    let a++\r\n    let a+=1\r\n    ((a++))\r\n\r\n**查出并杀死所有wireshark的进程**：\r\n\r\n```sh\r\nsudo kill `ps -ef | grep wireshark | grep -v grep | awk \'{print $1}\'`\r\n```\r\n\r\n**杀死所有的ping进程**：\r\n\r\n```sh\r\nfor i in `ps -x | grep ping | awk \'{print $1}\'`; do kill $i; done\r\n```\r\n\r\n**for语句输出1-15，共15个数字**：\r\n\r\n```sh\r\nfor i in {1..15}; do echo $i; done\r\n```\r\n  \r\n#### 终端命令行快捷方式\r\n- `ctrl + K`， `crtl + U`， `ctrl + W`， `ctrl + Y`\r\n   ```\r\n   ctrl+K 把光标后面（右面）的命令剪切掉，\r\n   ctrl+U 把光标前面（左面）的命令剪切掉，\r\n   ctrl+W 把光标前面的一个字（以空格分界）剪切掉，\r\n   ctrl+Y 把剪切的内容粘贴回来\r\n   ```\r\n- `ctrl + X + E`\r\n   ```\r\n   开启一个临时文本编辑器，用来编辑需要换行的命令，这样编辑会更直观\r\n   ```\r\n\r\n- `alt + . (点)`\r\n   ```\r\n   上一个命令的参数\r\n   ```\r\n   \r\n#### grep的使用\r\n\r\ngrep（global regular expression print，全局正则表达式输出）\r\n\r\n- 在文件中（或多个文件中）查找\r\n\r\n      #在/etc/passwd中查找单词\"root\"\r\n      zyy@Lap:~$ grep root /etc/passwd\r\n      root:x:0:0:root:/root:/bin/bash\r\n      zyy@Lap:~$\r\n      \r\n      #使用 -n 参数在结果中显示行号\r\n      zyy@Lap:~$ grep -n zyy /etc/group\r\n      18:cdrom:x:24:zyy\r\n      19:floppy:x:25:zyy\r\n      62:zyy:x:1000:\r\n      67:wireshark:x:126:zyy\r\n      zyy@Lap:~$ \r\n      \r\n      #使用^符号输出以某开头的行，使用$符号输出以某结尾的行\r\n      zyy@Lap:~$ grep ^zyy /etc/group\r\n      zyy:x:1000:\r\n      zyy@Lap:~$\r\n      \r\n- 使用 -l 参数列出包含指定模式的文件名\r\n\r\n- -v 参数使用反选模式\r\n\r\n- 使用 -r 参数递归查找\r\n\r\n- 使用 -i 忽略大小写\r\n\r\n#### 一些软件\r\n\r\ntsocks, putty, certbot（申请SSL证书）',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,78),(2,'关于','start-page',1582904820,1582964398,'<!--markdown-->本页面由 Typecho 创建, 这只是个测试页面.\r\n\r\n[托管在github pages的老站](https://github.zhangyongyao.com)',1,1,NULL,'page','publish',NULL,0,'1','1','1',0,0),(3,'华为（Huawei）网络设备命令手册','3',1504022400,1587808689,'<!--markdown-->#### 基本命令\r\n\r\n`display bridge mac-address`：查看设备自身的MAC地址\r\n\r\n`display as access configuration`：查看as设备的信息\r\n\r\n`display interface ethernet brief`：查看以太网接口的简要信息\r\n\r\n`display device manufacture-info`：查看设备制造信息，包括SN号\r\n\r\n`display version`：查看运行时间、软件版本\r\n\r\n`display vap`：查看无线VAP信息\r\n\r\n`display efm session all`：查看efm状态\r\n\r\n`display icmp statistics`：查看icmp收发状态\r\n\r\n`display ap-address info`：查看ap的地址信息\r\n\r\n`display mac-address [interface]`： 查看接口学到的mac表项\r\n\r\n`display cpu-usage`：查看cpu使用率，diagnose模式下可以显示详细的进程\r\n\r\n`display wlan wsta peak-statistics`：diagnose模式下查看用户periodic情况\r\n\r\n`reset factory-configuration`：恢复出厂设置\r\n\r\n`reset counters interface`：<用户视图>下，清除接口的统计信息\r\n\r\n`switchover mode nonstop-routing`：不间断路由\r\n\r\n#### 调试命令\r\n`terminal debugging`：开启终端调试功能\r\n\r\n`display logbuffer`：查看设备的日志\r\n\r\n    cd log_file\r\n    more log.log    查看更多的日志\r\n\r\n`reset logbuffer`：清除设备日志\r\n\r\n`display save time`：显示配置有无保存\r\n\r\n调试时关闭不需要的打印干扰：\r\n```sh\r\nundo terminal alarm\r\nundo terminal logging\r\nundo terminal trapping\r\n```\r\n\r\n##### 使用trace\r\n\r\n    <Huawei> terminal monitor\r\n    <Huawei> terminal debug\r\n    <Huawei> system-view\r\n    [Huawei] trace enable\r\n    [Huawei] trace access-user object 1 mac-address {mac}\r\n    [Huawei] undo trace enable //得到信息后关闭trace//得到信息后关闭trace\r\n\r\n#### 设备升级\r\n`display startup`：查看本次启动的信息\r\n\r\n`startup system-software {file.cc}`：升级软件\r\n\r\n`startup patch {patch.pat}`：升级补丁\r\n\r\n`delete {file}`：删除flash中的文件，不会释放空间，可以通过回收站恢复\r\n\r\n`reset recycle-bin`：清空回收站，释放flash空间\r\n\r\n升级版本后，可使用`check startup crc next`：检查下次启动的文件是否正常\r\n\r\n`<HUAWEI> undo workmode`： 从云管理模式切换为普通模式\r\n\r\n#### 交换机光口无法关闭自协商\r\n在万兆口使用`undo negotiation auto`关闭自协商时，提示：Error:This port or this mode does not support this command.\r\n\r\n由于万兆口都是默认强制为万兆的，所以万兆口下面没有自协商模式，无法关闭自协商，其他口可以正常执行。S5700系列的交换机万兆口下都无法关闭自协商。\r\n\r\n#### 交换机的AS状态不刷新\r\n这可能是因为AS与控制器之间的CAPWAP隧道异常导致的。\r\n1. 删除控制器上指定的capwap源接口:`undo capwap source interface {interface}`\r\n2. 再重新配置capwap源接口，让AS与控制器重新建立管理隧道，刷新数据。\r\n\r\n#### 边缘端口与BPDU保护\r\n启用边缘端口特性，使该端口不参与stp计算，并快速过渡之转发状态，命令:`[接口模式]# stp edged-port enable`\r\n\r\n启用bpdu保护特性，当边缘端口接收到bpdu报文时，交换机会shutdown该端口，同时记录事件，如果不启用该特性，当边缘端口接收到bpdu报文时会转化为非边缘端口，并重新计算生成树，从而引起网络动荡。命令：`[接口模式]# stp bpdu-protection`\r\n\r\n要恢复被shutdown的bpdu受保护边缘端口，可手工`undo shutdown`，或采用自动恢复的方式：系统视图下执行命令`error-down auto-recovery cause cause-item interval {time_of_second}`\r\n\r\n#### 报错信息\r\n\r\n`Error:failed to run this command because the connection was closed by remote host`\r\n\r\n这个log表示用户级别太低，没有权限执行这个命令，提升用户级别可以解决。\r\n\r\n#### 用户在线探测，用户同步\r\n**user-detect interval 60 retry 2**\r\n> 用户探测报文发送周期为60s（默认15s），重试2次(默认3次)，达到最大时间后（例子中是180s）没有收到用户的响应报文，认为用户下线。\r\n\r\n**access-user arp-detect vlan 1 ip-address 1.1.1.1 mac-address aabb-ccdd-eeff**\r\n>设置用户在线探测报文的源IP、源MAC及VLAN。如果在周期内收到用户的ARP回复，认定用户在线。\r\n\r\n**usr-sync interval 600**\r\n>接入设备每600s把所有在线用户的MAC通过capwap隧道发送给核心设备。\r\n\r\n#### AAA认证\r\nAAA可以通过域来对用户进行管理，不同的域可以关联不同的认证、授权和计费方案\r\n```sh\r\ndisplay domain #查看设备上存在的域\r\ndisplay domain name default_admin #查看default_domain域的详细情况\r\ndispaly authentication-scheme default #查看认证方案default的详细情况\r\n```\r\n\r\n对于单MAC多IP的终端，多个IP地址必须都通过认证终端才能上线。\r\n使能`ip-static-user enable`功能，满足单MAC多IP地址终端的上线需求。\r\n\r\n##### 给域关联AAA认证的步骤（本节可能有误，待修改）\r\n1. 创建认证服务器模板(radius服务器模板)：\r\n```sh\r\n    radius-server template example_radius_server\r\n      radius-server authentication x.x.x.x 1812\r\n      radius-server accouting x.x.x.x 1813\r\n      radius-server shared-key cipher password\r\n```\r\n2. 创建认证方案：\r\n```\r\n    authentication-scheme example_authen_sch\r\n      authentication-mode radius\r\n```\r\n3. 计费方案\r\n```\r\n    accounting-scheme example_account_sch\r\n      accounting-mode radius\r\n```\r\n4. 创建域，并管联方案    \r\n```sh\r\n    domain expamle_domain\r\n      radius-server example_radius_server #关联认证服务器\r\n      authentication-scheme example_authen_sch #关联认证方案\r\n      accounting-scheme example_account_sch #关联计费方案\r\n```\r\n\r\n##### 命令行快捷键\r\n`ctrl + a`：移动到行头\r\n\r\n`ctrl + b`：向左移动一个字符\r\n\r\n`ctrl + f`：向右移动一个字符',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,74),(4,'查看Outlook邮箱存档文件的方法','4',1504627200,1582990523,'<!--markdown-->使用Outlook时，会把几天以前的旧邮件存档，保存为文件，这样在邮箱的文件夹内是无法查看的。\r\n\r\n查看方法：\r\n\r\n>在主界面左侧边栏有个>符号，点开它以后，有收藏夹、用户邮箱、存档这三个选项，在`存档`里面就可以查看以往的邮件\r\n\r\n查找保存的文件路径：\r\n>在文件夹上右键-属性，弹出属性对话框，选择自动存档选项卡，就可以看到文件的路径，如果使用默认设置，需要点击“默认存档设置”才能看到文件路径。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,61),(5,'Pycharm使用技巧','5',1504627200,1582990594,'<!--markdown-->\r\n`Ctrl`+`Shift`+`上下方向键`：可以上下移动光标所在的整行，或者选择的行\r\n\r\n`Ctrl`+`p`：显示函数、类的参数或方法\r\n\r\n`Alt`+`Shift`+`c`：显示最近的修改\r\n\r\n`Alt + F6`：重命名变量\r\n\r\n`Ctrl + Alt + T`：选择code blocks，自动生成 if、try except等\r\n\r\nCommit时，在Commit Messages中按`Ctrl`+`空格`会显示所有有改动的文件，新增的文件以细体字显示',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,73),(6,'BFD-双向转发检测','6',1509206400,1582990692,'<!--markdown-->BFD（Bidirectional Forwarding Detection，双向转发检测），是一种实现网络可靠性的机制，它可以被用于快速检测网络中的链路状况、IP可达性等。BFD可以与多种协议或机制进行联动，以确保它们更加可靠的工作，例如静态路由、OSPF、IS-IS、BGP、VRRP、PIM、及MPLS LSP等。\r\n\r\n##### 配置\r\n```\r\n[系统视图] bfd //全局启用BFD\r\n[系统试图] quit\r\n[系统视图] bfd atob bind peer-ip default-ip interface g0/0/0\r\n[bfd视图] discriminator local 10 //本端标识符\r\n[bfd视图] discriminator remote 20 //远端标识符\r\n[bfd视图] commit //确认修改\r\n\r\n```\r\n###### 配置说明\r\n`bfd atob bind peer-ip default-ip interface g0/0/0`：创建BFD会话，对端IP使用默认组播地址\r\n##### 信息查看\r\n`display bfd session all verbose`：显示BFD的详细信息',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,73),(8,'一些Windows系统的小技巧','8',1510761600,1582990994,'<!--markdown-->\r\n#### 快捷键\r\n`Windows`+`X`：WIN7系统中打开移动中心，可以设置亮度，音量，电源，无线，外部显示器，同步中心，演示设置\r\n\r\n#### 快捷命令\r\n\r\n`control userpasswords2`：设置用户登陆不需要密码\r\n\r\n`devmgmt.msc`：设备管理器\r\n\r\n`compmgmt.msc`：计算机管理（相当于右键计算机-管理）\r\n\r\n`secpol.msc`：本地安全策略\r\n\r\n\r\n\r\n#### 命令行\r\nnetstat -ano\r\n\r\n`netsh http show srvicestate`：查看http端口使用情况\r\n\r\n`netsh interface tcp show global`：查看本机上启用的TCP参数\r\n\r\nsc ac HTTP\r\n\r\n`attrib`：修改文件属性\r\n\r\n#### IP地址为169.x.x.x的原因\r\n\r\n1. 通过DHCP获取IP失败\r\n\r\n2. 手动配置的IP地址与网络中其他主机的IP冲突\r\n\r\n#### 一些软件\r\n\r\ndism++, potplayer, putty, wireshark',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,68),(9,'pyQt5-QMainWindow设置布局管理出错','9',1512835200,1582991171,'<!--markdown-->在QMainWindow设置布局管理器时会报错，提示它已有了layout\r\n\r\n### 错误提示：\r\n\r\n>QWidget::setLayout: Attempting to set QLayout \"\" on MainWindow \"\", which already has a layout\r\n\r\n### 原因：\r\n\r\nYou can\'t set a QLayout directly on the QMainWindow. You need to create a QWidget and set it as the central widget on the QMainWindow and assign the QLayout to that.\r\n```\r\nwid = QtGui.QWidget(self)\r\nself.setCentralWidget(wid)\r\nlayout = QtGui.QVBoxLayout()\r\nwid.setLayout(layout)\r\n```\r\n\r\n参考链接：[stackoverflow](https://stackoverflow.com/questions/37304684/qwidgetsetlayout-attempting-to-set-qlayout-on-mainwindow-which-already)\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,87),(10,'Win7和Debian双系统启动顺序修改','10',1513267200,1582991482,'<!--markdown-->转载自：[win7，Ubuntu 12.04 双系统修改启动项顺序三方法](http://www.cnblogs.com/Duahanlang/p/3811465.html)\r\n\r\n本文所涉及的方法都是在Ubuntu的安装时将引导加载程序grub安装在了整个硬盘（即MBR内），即开机以grub引导。\r\n\r\n### 方法1\r\n在Ubuntu终端下输入：\r\n```\r\nsudo mv /etc/grub.d/30_os-prober /etc/grub.d/08_os-prober\r\nsudo update-grub\r\n```\r\n该命令是将etc文件夹下的grub.d文件夹下的30_os-prober文件改名为08_os-prober。（08可以改为06~09都可以）。 Ubuntu的启动项相关文件名为“10_....”这样就可以将win7的启动项放在Ubuntu前面，即启动项列表的第一个。由于引导程序默认启动第 一个启动项，所以这样就可以先启动win7了。注意修改完后更新一下grub才能生效（即命令sudo update-grub）。\r\n\r\n### 方法2\r\n在Ubuntu终端下输入：\r\n```\r\nsudo gedit /etc/default/grub\r\nsudo update-grub\r\n```\r\n在打开的文本中修改“GRUB_DEFAULT=0”这一项。比如win7在启动项列表中为第5项，则将0改为4。就是win7在启动项列表中的项数减1。\r\n这里还可以修改该在启动项列表等待的时间，即修改“GRUB_TIMEOUT=所要等待的秒数”，-1表示不倒计时。\r\n修改完后按`Ctrl`+`X`，会提示是否保存，输入`Y`，提示保存的文件名，还是原来的grub文件，所以直接回车确定。\r\n`sudo update-grub`，更新一下grub。\r\n\r\n### 方法3\r\n在Ubuntu终端下输入：\r\n```\r\nsudo gedit /boot/grub/grub.cfg\r\n```\r\n这个方法是编辑 /boot/grub/grub.cfg文件，\r\n\r\n在打开的文本中修改set default=\"0” 这一项。比如win7在启动项列表中为第5项，则将0改为4。就是win7在启动项列表中的项数减1。\r\n\r\n这里还可以修改该在启动项列表等待的时间，即修改“set timeout=10”，-1表示不倒计时。\r\n修改完后按`Ctrl`+`s`，保存后直接关闭。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,72),(11,'CWNA学习笔记','11',1514131200,1582991647,'<!--markdown-->#### 通信基础\r\n**载波信号**：交流或直流信号本身不具备传输数据的能力，如果转换后的信号可以区分0和1,一般将其称为`载波信号`。调整信号以产生载波信号的过程称为`调制`。\r\n\r\n**键控法**：调控信号使其表示不同数据的方式称为`键控法`，又称`调制技术`。键控法将信号转换为载波信号，数据经过编码以便传输。\r\n\r\n**三种键控法**：幅移键控（Amplitude-ShiftKeying, ASK）、频移键控（Frequency-Shift Keying, FSK）和相移键控（Phase-Shift Keying, PSK）\r\n\r\n\r\n\r\n#### 射频基础\r\n射频信号传播时会有多种行为，也被称为传播行为，如吸收、反射、散射、折射、衍射、自由空间路径损耗、多径现象、增强和衰减。\r\n\r\n##### 射频组件\r\n**发射机**：发射机把计算机数据通过调制技术进行交流信号修改，并将数据在信号中进行编码。这个被调制的交流信号作为载波信号容纳需要发送的数据。载波信号随即被直接或通过馈线发送给天线。发射机还负责确定原始的传输振幅，通常也称为发射机的功率等级（power level），无线电波的振幅越高，能量就越强，传送也越远。\r\n\r\n**天线**：有两种方法可以增强天线的输出功率。第一种方法是增加发射机的功率，另一种方法是对射频信号进行定向或聚焦辐射。\r\n\r\n天线信号通常与各向同性辐射体对比。`各向同性辐射体（isotropic radiator）`是指信号强度在各个方向均进行等效辐射的点状发射源。\r\n\r\n**接收机**：接收机从天线接收载波信号并把信号调制成1和0,再把这些数据传给计算机处理。\r\n\r\n**主动辐射器（IR）**：主动辐射器（Intentional Radiator），包括从发射机到天线之间的所有组件，但不包括天线。IR是原始的能量或信号，天线再对这个信号进行聚焦。\r\n\r\n**等效全向辐射功率**：天线具有聚焦射频能量的能力，聚焦能力可以使天线的有效输出比天线输入信号更强。等效全向辐射功率（EIRP）是指从天线发出的最大射频信号强度。\r\n\r\n**分贝**：它是一个相对单位，用来描述两个数值之间的差异，定义两个功率比为10：1时为1贝尔。\r\n\r\n贝尔（bels）=log<sub>10</sub>(P<sub>1</sub>/P<sub>2</sub>)\r\n\r\n分贝（decibels）=10×log<sub>10</sub>(P<sub>1</sub>/P<sub>2</sub>)\r\n\r\n**dBi**：天线与各向同性辐射体相比功率的增益称为decibels isotropic(dBi)，指的是天线的增益。\r\n\r\n2.4GHz的半波偶极天线增益为2.14dBi\r\n\r\n**dBd**：指与偶极天线信号相比的天线增益。如果一根天线的增益为3dBd，意味着该天线比偶极天线增益高出3dBi，所以3dBd的天线增益为5.14dBi。\r\n\r\n**dBm**：dBm是比较信号强度与1mW之间的关系。指的就是相对于1mW的dB值。规定0dBm代表1mW。\r\n\r\ndBm=10×log<sub>10</sub>(P<sub>mW</sub>)\r\n\r\n##### 自由空间路径损耗公式\r\n\r\nFSPL = 32.4 + (20log<sub>10</sub>(F)) + (20log<sub>10</sub>(D))\r\n\r\nFSPL = 路径损耗（dB)\r\n\r\nF = 频率（MHz)\r\n\r\nD = 与天线之间的距离（km)\r\n\r\n**6dB规则**\r\n\r\n增加6dB会使可用信号距离加倍\r\n\r\n减少6dB会使可用信号距离减半\r\n\r\n**10与3规则**\r\n\r\n每3dB的增益（相对值），绝对功率（mW）加倍\r\n\r\n每3dB的损耗（相对值），绝对功率（mW）减半\r\n\r\n每10dB的增益（相对值），绝对功率（mW）乘10\r\n\r\n每10dB的损耗（相对值），绝对功率（mW）除10\r\n\r\n**本底噪声**：是某个特定信道的环境或背景的射频能量级别。任何电磁设备都有可能提高在某个特定信道的本底噪声的振幅。本底噪声的振幅有时也简称为背景噪声。\r\n\r\n**信噪比(SNR)**：许多Wi-Fi供应商把信号质量定义为信噪比(SNR)，SNR是接收信号与背景噪声水平之间的差值。25dB或以上的信噪比被认为信号质量很好，而10dB或以下的信噪比被认为信号质量很糟糕。\r\n\r\n\r\n**接收信号强度指示(RSSI)**：接收灵敏度(Receive sensitivity)是指接收机可以成功接收所需的射频信号功率等级。接收机可以成功接收的功率水平越低，表明接收灵敏度越好。\r\n\r\n在802.11-2007标准中，接收信号强度指示(Received Signal Strength Indicator, RSSI)的定义为802.11射频模块测量信号强度的相关指标。RSSI测量参数范围为0~255。RSSI指标通常被映射为接收敏感阈值(单位 dBm)。Wi-Fi供应商通常指定其产品的接收灵敏阈值为不同的数据速率。\r\n\r\n**链路预算**：指从发射机开始通过射频媒介直到接收机之间的所有增益和衰减。链路预算计算的目的是确保最终接收信号强度处于接收机的接收灵敏阈值之上。\r\n\r\n**衰落容限/系统操作容限**：指超过被要求信号阈值之上的部分。接收信号很容易受到外界影响而产生波动，为了适应这种波动，在桥接链路中通常在射频接收灵敏阈值之上预留出10dB到20dB5的缓冲，这个缓冲就称为衰落容限。\r\n\r\n#### 射频信号与天线概念\r\n方位图（azimuth chart）与正视图（elevation chart）称为极化图（polar chart）或天线辐射包络图（antenna radiation envelope）。\r\n\r\n**方位图**为H面，表示天线辐射图的俯视图，**正视图**为E面，表示天线辐射图的侧视图。\r\n\r\n极化图的外圆一般表示天线信号最强的部分。注意，极化图并不表示距离或功率（强度）大小，它只是表示图中不同点功率之间的关系。\r\n\r\n**波束宽度**：功率峰值点开始，两个半功率点之间的夹角。\r\n\r\n水平波束宽度：在水平方向上，在最大辐射（峰值）方向两侧，辐射功率下降3dB的两个点（半功率点）的夹角。\r\n\r\n垂直波束宽度：在垂直方向上，在最大辐射方向两侧，辐射功率下降3dB的两个点的夹角。\r\n\r\n一般天线增益越大，聚焦能力越强，波束越窄。\r\n\r\n#### 无线局域网拓扑结构\r\n802.11标准定义了4种不同的802.11拓扑结构，它们称为服务集，服务集描述了无线射频卡之间的通信方式。它们分别是BSS（Basic Service Set，基础服务集）、ESS（Extented Service Set，扩展服务集）、IBSS（Independent Basic Service Set，独立基础服务集）与MBSS（Mesh 服务集）。\r\n\r\n#### 802.11媒介访问\r\nIEEE 802.11无线局域网采用半双工通信，802.11无线客户端没有同时进行传输和接收的能力，所以无法在传输时检测冲突。\r\n\r\n* CSMA/CA\r\n  >载波侦听(carrier sense)用来检测传输媒介是否繁忙。多路访问(multiple access)用来确保每一个无线终端可以进行公平的媒介访问（但每次只能有一个终端传输）。冲突避免(collision avoidance)意味着在指定时间内只有一个无线终端可以得到媒介访问能力，希望借此避免冲突。\r\n  \r\n##### 冲突检测\r\n如果无法检测冲突，那么又如何知道冲突发生？802.11无线终端每传输一个单播帧，接收端会回复确认(ACK)帧以证明该帧被正确接收。\r\n\r\n广播和多播帧并不要求确认。如果发送端没有收到ACK帧，即单播帧未得到确认，该帧就不得不重传。\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,74),(12,'python的内置甜点函数','12',1514563200,1587808746,'<!--markdown-->#### enumerate\r\n{% highlight python linenos %}\r\n>>> l = [\'a\', \'b\', 12, \'d\']\r\n>>> for i, d in enumerate(l):\r\n...     print(i, d)\r\n...\r\n0 a\r\n1 b\r\n2 12\r\n3 d\r\n{% endhighlight %}\r\n\r\n#### zip\r\n{%highlight python linenos %}\r\n>>> l = [\'a\', \'b\', \'c\', \'d\']\r\n>>> n = [\'1\', \'2\', \'3\', \'4\']\r\n>>> for i, m in zip(l, n):\r\n...     print(i, m)\r\n...\r\na 1\r\nb 2\r\nc 3\r\nd 4\r\n{%endhighlight%}\r\n\r\n#### splitlines, strip, rstrip\r\n`str.splitlines(keepends)`：按照行（\\r,\\n,\\r\\n）分隔字符串,返回一个列表。如果参数keepends为False，不保留换行符，如果为True，则保留换行符。\r\n\r\n`str.strip(chars)`：移除字符串**首尾**指定的字符，默认为空格。\r\n\r\n`str.rstip(chars)`：移除字符串**末尾**指定的字符，默认为空格。\r\n\r\n#### str.format\r\n\'<\': Forces the field to be left-aligned within the available space (this is the default for most objects).\r\n\r\n\'>\':  	Forces the field to be right-aligned within the available space (this is the default for numbers).\r\n\r\n#### f-string\r\npython3.6开始支持此特性\r\n```python\r\nname = \'root\'\r\nage = 12\r\nf\'im {name}\' # im root\r\nF\'im {name}, im {age}\' # im root, im 12\r\n```\r\n#### 性能测试\r\n使用**timeit**模块\r\n\r\n### 类型标注\r\n\r\n```\r\ndef greeting(name: str) -> str:\r\n    return \"Hello\" + name\r\n```\r\n这个函数的输入被标注为是字符串(str)，返回值也被标注为字符串。\r\n\r\n[官方doc](https://docs.python.org/3.1/library/string.html)',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,76),(13,'正则表达式','13',1516118400,1582991771,'<!--markdown-->`\\r`表示回车符（CR Carriage-Return），`\\n`表示换行符（LF Line-Feed），Windows使用CRLF换行，Unix/Linux使用LF，MAC使用CR\r\n\r\n`\\s`：匹配任何空白字符，包括空格、制表符、换页符等等\r\n\r\n`\\S`：匹配任何非空白字符\r\n\r\n`.`：匹配除换行符`\\n`之外的任何单字符\r\n\r\n`^`：匹配以字符串开始的位置\r\n\r\n`$`：匹配以字符串结束的位置\r\n\r\n`{n,m}`：匹配的次数，其中n<=m\r\n\r\n*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个？就可以实现非贪婪或最小匹配。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,69),(14,'python3读取excel','14',1516118400,1582991922,'<!--markdown-->```python\r\nimport xlrd\r\nwb = xlrd.open_workbook(\'test.xlsx\')\r\n#查看包含的工作表\r\nsheetnames = wb.sheet_names()\r\n#获取一个表的四种方法\r\nsheet = wb.sheet_by_name(\'Sheet1\')\r\nsheet = wb.sheets()[0]\r\nsheet = wb.sheet_by_index(0)\r\nsheet = wb[\'Sheet1\']\r\n#行数和列数\r\nnrows = sheet.nrows\r\nncols = sheet.ncols\r\n#枚举所有行/列\r\nsheet.iter_rows(min_row=2)\r\nsheet.iter_columns()\r\n\r\n#单元格0行1列的值\r\nsheet.cell(0,1).value\r\n#第一列/行的值?\r\nsheet.col_values(0)\r\nsheet.row_values(0)\r\n#cell的位置\r\n列(column)以1开始，行(row)以0开始\r\ncell = [\'B5\']\r\ncell.row // 5\r\ncell.column //B\r\ncell.col_idx //2\r\n#写入\r\nsheet.cell(column=1, row=0, value=\'a\')\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,85),(15,'vim使用方法','15',1518624000,1583245710,'<!--markdown--># 搜索查找\r\n`/foo`：查找字符串foo\r\n\r\n`n`：查找下一个\r\n\r\n`N`：查找上一个\r\n\r\n> 查找支持正则表达式，例如`/vim$`匹配行尾的vim\r\n> 查找特殊字符需要转义，例如`/vim\\$`匹配vim$\r\n\r\n## 大小写敏感\r\n查找时在末尾添加`\\c`表示不敏感查找，`\\C`表示大小写敏感查找。例如：`/foo\\c`，将会查找所有的\"foo\",\"FOO\",\"Foo\"等字符串。\r\n\r\nvim默认采用大小写敏感查找，可以配置其他查找方式：\r\n```\r\nset ignorecase  #设置大小写不敏感查找\r\nset smartcase  #如果有大写字母，则切换到大小写敏感查找\r\n```\r\n## 查找当前词\r\n在normal模式下，按`*`(星号)可查找光标所在的词（word），前后为空白字符或标点符号。比如当前词为foo，可以匹配foo bar中的foo，但是foobar中的foo不能匹配。\r\n\r\n按`g*`可以匹配当前词的字符串序列，如果当前词为foo，可以匹配foo bar和foobar中的foo都可以被匹配到。\r\n\r\n# 查找替换\r\n`:s`命令用来查找和替换字符串。语法如下：\r\n`:{作用范围}s/{查找目标}/{替换为}/{替换标志}`\r\n\r\n例如：`:%s/foo/bar/g`会在全文范围内（%）查找foo并替换为bar，所有出现都会被替换（g）。\r\n\r\n**作用范围标识符**\r\n作用范围标识分为当前行、全文、选区等等。\r\n当前行为`空`：`:s/foo/bar/g`；\r\n全文为`%`：`:%s/foo/bar/g`；\r\n1-5行为`1,5`：`:1-5s/foo/bar/g`；\r\n当前行与接下两行`.,+2`：`:.,+2s/foo/bar/g`；\r\n选区，在Visul模式下选择区域后输入`:`，vim自动补全为`:\'<,\'>`，如:`\'<,\'>s/foo/bar/g`；\r\n\r\n**替换标志**\r\n标志为空表示从光标位置开始：`:%s/foo/bar`；\r\n`i`表示大小写不敏感，`I`表示大小写敏感；\r\n`c`表示需要确认，会询问 replace with bar (y/n/a/q/l/^E/^Y)?，按下`y`表示替换，`n`表示不替换，`a`表示替换所有，`q`表示退出查找模式，`l`表示替换当前位置并退出。`^E`与`^Y`是光标移动快捷键；\r\n\r\n# 移动命令\r\n`w`：向前移动一个单词\r\n\r\n`b`：向后移动一个单词\r\n\r\n`^`：移动到本行第一个非空白字符上\r\n\r\n`0`,`HOME`：移动到本行第一个字符上\r\n\r\n`$`：移动到行尾\r\n\r\n`gg`：光标移动到文件首\r\n\r\n`G`：光标移动到文件尾\r\n\r\n`nG`：光标移动至第n行的行首\r\n\r\n# 模式切换\r\n`v`：可视模式（逐字）\r\n\r\n`V`：可视模式（逐行）\r\n\r\n`:!command`：不退出vim并执行命令\r\n\r\n# 撤销和重做\r\n`u`：撤销\r\n\r\n`Ctrl + r`：重做\r\n\r\n# 复制和粘贴\r\n\r\n`yy`：拷贝当前行\r\n\r\n`dd`：剪切当前行\r\n\r\n`p`：在当前行下粘贴\r\n\r\n可视模式下，`y`和`d`可以选择复制和粘贴\r\n\r\n# 设置\r\n大多数设置既可以保存到`~/.vimrc`中永久生效，也可以用`:set nu`的方式临时使用。\r\n\r\n```\r\n:set nu 显示行号\r\n:syntax on 语法高亮\r\n:set cindent 自动缩进\r\n:%!xxd 二进制编辑视图\r\n```\r\n## 高亮设置 TODO\r\n\r\n设置TAB为4个空格的方法，编辑`.vimrc`：\r\n```\r\nset ts=4\r\nset expandtab\r\n```\r\n\r\n```\r\nvim -b filename 以二进制打开文件\r\n```\r\n\r\n参考1：[vim全局，局部查找 替换字符串](https://blog.csdn.net/qq_35624263/article/details/77181057?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,70),(16,'python中str与bytes之间转换','16',1519488000,1583025516,'<!--markdown-->python中字符串(str)与字节(bytes)之间的转换方法\r\n\r\n{%highlight python linenos%}\r\n\r\nb = b\'example\'\r\ns =  \'example\'\r\n\r\n# str to bytes\r\nbytes(s, encoding=\'utf8\')\r\nstr.encode(s)\r\n\r\n# bytes to str\r\nstr(b, encoding=\'utf8\')\r\nbytes.decode(b)\r\n\r\n{%endhighlight%}',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,90),(17,'华为AC常用命令和WLAN基础','17',1522512000,1587222610,'<!--markdown--># AC的一些操作命令\r\n\r\n* **display wlan calibrate statistics**\r\n  >输出信息描述：\r\n  >\r\n  >signal environment deteriaration 信号环境恶化次数\r\n  >\r\n  >power/channel calibration 功率/信道调整次数\r\n  \r\n* **display ap neghbor ap-id 233 radio 1**\r\n    >查看AP指定射频的邻居信息\r\n    \r\n* **display ap sta-signal strength ap-id 1**\r\n    >查看AP上STA的平均信号强度\r\n    \r\n* **display ap traffic statistics wireless**\r\n    >查看AP射频上的报文统计数\r\n\r\n* **display vap ap-id {ap-id}**\r\n    >查看某个AP开放的SSID\r\n\r\n* **display vap all**\r\n    >查看每个AP开放的SSID\r\n\r\n* **display radio ap-id {ap-id}**\r\n    >查看AP的信道信息（包括信道的带宽、信号强度、关联数量、信道利用率、工作模式等\r\n\r\n# 离线添加AP上线的基本配置\r\n\r\n离线添加的AP需要有以下基本配置才会上线：\r\n\r\n1. IP地址方式改为static，默认是DHCP方式\r\n2. IP：AP需要一个IP来建立CAPWAP隧道。否则AP不会尝试建立CAPWAP隧道，AC上会显示AP是Idle状态。另外如果没有配置AC，会以广播方式请求建立；如果有AC，又分为同网段与不同网段两种情况。\r\n\r\nAC需要以下配置：\r\n1. 指定CAPWAP源：如果没有指定CAPWAP源，AC不会响应AP的CAPWAP建立请求。**AC设置CAPWAP源后重启才会生效**。\r\n2. 认证模式：默认是MAC认证\r\n2. 添加AP：如`ap-id 0 ap-mac aabb-ccdd-eeff`会添加一个MAC为aabb-ccdd-eeff的AP，AP认证通过后AC会自动添加type-id和sn。\r\n\r\n#### Notes\r\n1. 如果AP和AC在同一网段，AP会ARP得到AC的MAC，然后向AC单播{二层，三层？}CAPWAP协议的discovery request。连续10个包没有回应，会广播一个discovery request,如此反复。**AP没有与AC建立CAPWAP隧道时，会处于idle状态**。\r\n\r\n2. 如果AP和AC不在同一网段，AP会先验证网络的连通性，然后向AC单播{三层？}CAPWAP协议的discovery request。连续10个包没有回应，会广播一个discovery request,如此反复。\r\n\r\n3. AP发送的discovery request报文里有WTP Board Data选项，该选项有vender、AP型号、AP的SN、AP的MAC，AC可以根据此选项回应相关报文。\r\n\r\n## AP配置\r\n```sh\r\n[系统视图]# ap-address mode static #这条命令是AP配置静态IP的前置条件\r\n[系统视图]# ap-adress static ip-address {ip} {pre-mask} #需要重启才生效\r\n[系统视图]# ap-address static ac-list {ip} #需要重启才生效\r\n[系统视图]# ap-mode-switch fat ftp {file-name} {ftp-server-ip} #把AP切换为FAT模式\r\n[系统视图]# ap-mode-switch check #检查设备文件系统状态是否允许形态切换，8030DN，8130DN不需要该命令\r\n[系统视图]# ap-mode-switch prepare #切换设备文件系统状态使FIT AP可以切换为FAT AP\r\n```\r\n\r\n# WLAN基本业务配置流程图\r\n\r\n![WLAN基本业务配置流程图](https://download.huawei.com/mdl/imgDownload?uuid=d8dbfa7ba914404bb6b09946ee89e44e.png)\r\n\r\n# WLAN模板引用关系图\r\n\r\n![WLAN模板引用关系图](https://download.huawei.com/mdl/imgDownload?uuid=08091058512b4755a3a6d408ae0a262d.png)\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,85),(18,'EFM(最后一公里以太网)','18',1522771200,1583028410,'<!--markdown-->最后一公里以太网（EFM：Ethernet in the First Mile）主要用于接入部分的以太网物理层规范及以太网管理和维护，是链路级的OAM（Operation and Management）。针对两台直连设备之间的链路，提供链路连通性检测功能，链路故障监控功能，远端故障通知功能和远端环回功能。\r\n\r\nEFM的RFC链接：[EFM RFC](https://www.rfc-editor.org/rfc/rfc4878.txt)\r\n\r\n#### 协议报文\r\nEFM OAM工作在链路层，其协议报文被称为OAMPDU。\r\n\r\nEFM是**慢速协议**（Slow Protocols），慢速协议报文的特点是不能被网桥转发。\r\n\r\n![报文格式](http://ov57zbjqo.bkt.clouddn.com/efm_oam_pdu.jpeg)\r\n\r\nEFM实体默认每秒发一个OAMPDU。\r\n\r\n#### EFM配置\r\n```\r\n[系统视图]# efm enable #全局开启EFM\r\n[接口视图]# efm enable #接口开启EFM\r\n[接口视图]# efm trigger {if-down | error-down}\r\n```\r\n\r\nif-down的接口下除EFM协议报文外的所有其他报文都无法被转发。如果当前接口通过EFM检测到链路连通性故障恢复，则会恢复该接口的所有报文转发。\r\n\r\nerror-down会把接口的管理状态置为admin down，而且需要用户手工决定是否回切（可以通过额外配置设置自动恢复）。\r\n\r\n#### 调试排错\r\n`display efm session all`：查看efm状态\r\n\r\n#### 参考文档\r\n[802.1ag CFM/802.3ah EFM OAM/Y.1731 ETH OAM学习笔记](https://blog.csdn.net/fw0124/article/details/5831096)\r\n\r\n[介绍EFM OAM和CFD以太网OAM技术](http://network.chinabyte.com/435/12331935_2.shtml)',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,61),(19,'linux设置ssh证书登陆','19',1523721600,1583028675,'<!--markdown-->用户生成密钥对，把公钥放在服务器上用户的认证文件中，用户登陆时使用私钥认证。\r\n\r\n# 得到密钥对\r\n生成openssh格式的公钥和私钥：可以使用ssh-keygen和putty-gen\r\n\r\n# Debian系服务器端设置\r\n编辑/etc/ssh/sshd_config\r\n>设置 PubkeyAuthentication yes\r\n\r\n重启ssh服务 systemctl restart ssh\r\n\r\n在用户的家目录下创建.ssh文件夹（注意所有者是用户，权限是755）\r\n\r\n把公钥安装在.ssh文件夹内的authorized_keys中（注意所有者是用户，权限是644）。\r\n\r\n安装方法：cat 公钥 >authorized_keys 或 公钥重命名为authorized_keys 或 ssh-copy-id hostname\r\n\r\n最好禁用root使用密码登陆\r\n\r\n# 小米路由器的Dropbear config\r\n\r\n[openwrt dropbear configuration](https://wiki.openwrt.org/doc/uci/dropbear)\r\n\r\n[Setup authorized_keys](https://wiki.openwrt.org/oldwiki/dropbearpublickeyauthenticationhowto)\r\n\r\n    vi /etc/config/dropbear\r\n    \r\n    config dropbear\r\n        option PasswordAuth \'off\'\r\n        option RootPasswordAuth \'off\'\r\n        option Port \'22\'\r\n        \r\n公钥存放目录：\r\n\r\n    cd /etc/dropbear/authorized_keys\r\n    chmod 0600 authorized_keys',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,68),(20,'linux设置VNC远程桌面服务器','20',1523721600,1583028819,'<!--markdown-->##### 使用x11vnc建立VNC服务器\r\n\r\n###### 安装x11vnc\r\n>apt install x11vnc\r\n\r\n###### 使用x11vnc\r\n> x11vnc -ncache 10 -forever -shared -bg -rfbport 5900 -rfbauth /root/.vnc/passwd -auth /var/run/lightdm/root/:0 -display :0\r\n\r\n###### 创建系统服务x11vnc.service\r\n>vim /lib/systemd/system/x11vnc.service\r\n\r\n```\r\n[Unit]\r\nDescription=start x11vnc at startup\r\n#注释\r\nAfter=multi-user.target\r\n\r\n[Service]\r\n#WorkingDirectory=\r\nExecStart=/usr/bin/x11vnc -ncache 10 -forever -shared -bg -rfbport 5900 -rfbauth /root/.vnc/passwd -auth /var/run/lightdm/root/:0 -display :0\r\nRestart=on-failure\r\n#or always\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n```\r\n\r\n###### 启用服务x11vnc.service\r\n```\r\nsystemctl enable x11vnc.service\r\nsystemctl daemon-reload\r\nsystemctl start x11vnc.service\r\n```\r\n\r\n###### 检查服务状态x11vnc.service\r\n{%highlight shell linenos %}\r\nsystemctl status x11vnc.service\r\njournalctl [-f] -u x11vnc.service\r\n{%endhighlight%}\r\n\r\n##### 使用noVNC建立基于web的vnc客户端\r\n###### 下载noVNC并解压 https://kanaka.github.io/noVNC/\r\n###### 使用noVNC连接到VNC服务器 ./noVNC/utils/launch.sh --vnc localhost:5900\r\n###### 通过noVNC主机的IP登陆noVNC <noVNC_host>:6080/vnc.html\r\n\r\n##### 说明\r\nx11vnc参数\r\n\r\n>x11vnc -noxrecord -forever -rfbport 5900 -rfbauth /root/.vnc/passwd -auth /var/lib/lightdm/.Xauthority -display :0\r\n\r\n-auth可用值\r\n```\r\n/var/run/lightdm/root/:0\r\n/var/lib/lightdm/.Xauthority\r\n```\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,79),(21,'华为交换机忘记密码怎么办','21',1525881600,1583028878,'<!--markdown-->#### 主要步骤\r\n\r\n1. 重启交换机。\r\n\r\n2. 重启过程中，根据提示按`Ctrl`+`B`进入bootload模式（如果需要密码，输入Admin@huawei.com）。\r\n\r\n3. 选择7清除console口的密码，并输入Y确认。\r\n\r\n4. 选择1重启交换机。\r\n\r\n#### 其他说明\r\n华为设备的默认状态，用户设置密码不能与最近5次使用的密码相同。可以通过下面的命令忽略该限制：\r\n```\r\n[aaa] reset local-user [user-name] password history record\r\n```\r\n或：\r\n```\r\n[aaa] local-aaa-user password policy administrator //进入管理员密码策略模式\r\n[aaa-admin-policy] password history record number [number] //把number设置为0\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,65),(22,'python使用getopt获取命令行参数','22',1528473600,1583028947,'<!--markdown-->#### 方法\r\n> getopt.getopt( args, shortopts, longopts=[])\r\n\r\n#### 例子\r\n```python\r\nimport getopt, sys\r\ndef main():\r\n    try:\r\n        opts, args = getopt.getopt(sys.argv[1:], \"ho:v\", [\"help\", \"output=\"])\r\n    except getopt.GetoptError as err:\r\n        # print help information and exit:\r\n        print(err)  # will print something like \"option -a not recognized\"\r\n        usage()\r\n        sys.exit(2)\r\n    output = None\r\n    verbose = False\r\n    for o, a in opts:\r\n        if o == \"-v\":\r\n            verbose = True\r\n        elif o in (\"-h\", \"--help\"):\r\n            usage()\r\n            sys.exit()\r\n        elif o in (\"-o\", \"--output\"):\r\n            output = a\r\n        else:\r\n            assert False, \"unhandled option\"\r\n    # ...\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n```\r\n\r\n#### 说明\r\n[官方doc](https://docs.python.org/3/library/getopt.html?highlight=getopt#module-getopt)',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,62),(23,'python列表赋值与深浅拷贝','23',1528560000,1583029074,'<!--markdown-->在高级语言中，变量是对内存及其地址的抽象。对于python而言，python的一切变量都是对象，变量的存储，采用了引用语义的方式，存储的只是一个变量的值所在的内存地址，而不是这个变量的值本身。\r\n\r\n#### 列表赋值\r\n```python\r\na = [1, 2]\r\n\r\n#复制方法\r\nb = a[:]\r\nb = a.copy()\r\n\r\n#如果使用b=a,则是引用，列表b和a都会指向同一个地址\r\nb = a\r\n```\r\n\r\n#### 深浅拷贝\r\n[python——赋值与深浅拷贝 Eva_J的blog](http://www.cnblogs.com/Eva-J/p/5534037.html)\r\n\r\n\r\n>在python中变量值 完全不等于 对象值。变量值是 对象所在的地址值。[id(variable_name)]\r\n>\r\n>赋值操作 是 计算等号右侧表达式，为获得的 结果对象 申请一块内存，并将其地址值赋给变量。\r\n>但如果 结果对象 已经存在于内存中，则并不会再次申请内存，而是直接将其地址值赋给变量。\r\n>\r\n\r\n作者：远辰\r\n\r\n链接：https://www.zhihu.com/question/20591688/answer/337507268\r\n\r\n来源：知乎\r\n\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,64),(24,'TCP/IP路由技术之001-TCP/IP简介','24',1528819200,1587808818,'<!--markdown-->[图]TCP/IP协议簇与OSI参考模型的关系\r\n\r\n![IP包头格式](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/IP%E6%8A%A5%E5%A4%B4.png \"IP包头格式\")\r\n\r\n\r\n**header length**(报头长度)：此字段长度为4位，单位是4字节，因此IP报头不会超过(2<sup>4</sup>-1)x4字节。\r\n\r\n**Type of Service**(服务类型)：此字段长度为8位，现已作为区分服务（Diffserv）被重新定义了。在Diffserv下，我们能够在一台路由器上定义服务分类，将数据包归类到这些分类中去，路由器可以根据它们的分类使用不同的优先级对数据包进行排序和转发。\r\n\r\n**Total Length**(总长度)：此字段长度为16位，单位是1字节，其中包括IP报头。\r\n\r\n**Identifier**(标识符)：此字段长度为16位，如果数据包原始长度超过数据包所要经过的数据链路的最大传输单元（MTU），那么必须将数据包分段为更小的数据包，被分段的数据包一直保持分段状态，直至到达最终目的时才会被重组。\r\n\r\n**Flag**(标记)：此字段长度为3位，其中第1位保留，第2位是不分段（DF）位。当DF位为1时，表示路由器不能对数据包进行分段处理，如果数据包由于不能被分段而未能被转发，那么路由器将丢弃该数据包并向源点发送错误消息。第3位是更多分段（MF）位，当路由器对数据包进行分段时，除了最后一个分段的MF位设置为0外，其他所有分段的MF位均设置为1,以便接收者直到收到MF位为0的分段为止。\r\n\r\n**Fragment Offset**(分段偏移)：此字段长度为13位，单位是8字节，用于指明分段起始点相对于报头起始点的偏移量，使接收者能够按照正确的顺序重组数据包。如果其中一个分段丢失，那么会对整个数据包重新分段并重新发送。\r\n\r\n**Header Checksum**(头部校验和)：校验和不计算被封装的数据，但由于每台路由器都会修改TTL值，所以每台路由器都会重新计算校验和。\r\n\r\n### 地址解析协议（ARP）\r\n路由器可以沿逻辑路径传送数据包，其中逻辑路径包括多个数据链路。沿独立的数据链路传送数据包时，需要把数据包封装在帧中，并且使用数据链路标识（如MAC地址）让帧可以从链路的源点到达目的地。\r\n\r\n数据链路上的设备需要一种方法发现邻居的数据链路标识，以便将数据帧传送到正确的目的地，IPv4使用ARP这种方法（详见[RFC826](https://tools.ietf.org/html/rfc826)）。\r\n\r\n当一台设备需要发现另一台设备的数据链路标识符时，它将建立一个ARP请求数据包，这个请求数据包中包括目标设备的IP地址以及发送者的IP和数据链路标识符（MAC地址）。然后ARP请求数据包被封装在数据帧中，该帧的源MAC为发送者，目的MAC为广播地址。\r\n\r\n![ARP](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/ARP%E6%8A%A5%E6%96%87.png \"ARP报文\")\r\n\r\n**硬件类型**：以太网为1。\r\n\r\n**协议类型**：指明了网络层协议的类型，IP对应0x0800。\r\n\r\n**硬件地址长度**：指定了数据链路标识符的长度，单位是1字节，MAC地址的长度为6。\r\n\r\n**协议地址长度**：指定了网络层地址的长度，单位是1字节，IPv4地址的长度为4。\r\n\r\n**操作**：指明了一个数据包是ARP请求（1）还是ARP响应（2），或其他。\r\n\r\n#### 代理ARP\r\n人如其名，代理ARP，详见[RFC925](https://tools.ietf.org/html/rfc925)和[RFC1027](https://tools.ietf.org/html/rfc1027)。\r\n\r\n#### 无故ARP\r\n主机偶尔也会使用自己的IPv4地址作为目标地址发送ARP请求，这种ARP请求称为无故ARP。\r\n- 无故ARP可以用于检查重复地址。一台设备可以向自己的IPv4地址发送ARP请求，如果发到ARP响应则表明存在重复地址。\r\n- 无故ARP还可以用于通告一个新的数据链路标识符。当一台设备收到一个ARP请求，如果ARP高速缓冲中已有发送者的IPv4地址，那么与此IPv4地址相对应的硬件地址将会被发送者新的硬件地址所更新。\r\n- 运行热备份路由器协议（HSRP）的路由器如果从其他路由器变成了主路由器，它就会发出一个无故ARP来更新网络上主机的ARP缓存。\r\n\r\n#### ICMP (Internet 消息控制协议)\r\n![ICMP报文格式](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/ICMP%E6%8A%A5%E6%96%87.png \"ICMP报文格式\")\r\n\r\nICMP报文可以通过类型来标识，而许多类型有多个子类型，可以用代码字段来标识它们。详见[RFC1700](https://tools.ietf.org/html/rfc1700)。\r\n\r\n### 传输层（主机到主机层）\r\n#### TCP（传输控制协议）\r\nTCP向应用提供了可靠的、面向连接的服务，也就是说TCP提供了一个类似于点到点的连接。\r\n\r\n点到点的连接有两个特点：\r\n- 仅存在一条到达目的地的路径。进入连接的数据包不会丢失，因为数据包惟一可去的地方就是连接的另一端。\r\n- 数据包到达的顺序与发送顺序相同。\r\n\r\nTCP使用了3种基础的机制实现面向连接的服务：\r\n- 使用序列号对数据包进行标记，以便TCP接收服务在向目的应用传递数据之前修正错序的数据包。\r\n- TCP 使用确认、校验和定时器系统提供可靠性。当接收者按照顺序识别出数据包未能到达或发生错误时，或者接收者在特定时间内没有发送确认信息，那么发送者就会认为在发送结束后数据包没有到达接收方。在这两种情况下，发送者都会考虑重传数据包。\r\n- TCP 使用窗口机制调整数据包的流量。窗口机制可以减少因接收方缓冲区满而造成丢失数据包的可能性。\r\n\r\n![TCP header](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/TCP%E6%8A%A5%E5%A4%B4.png \"TCP报文头部\")\r\n\r\n**序列号(Sequence Number)**：序列号确定了发送方发送的数据流中被封装的数据所在位置。例如，本段数据的序列号为1343,且数据段长512字节，那么下一数据段的序列号应该为1343+512+1=1856。\r\n\r\n**确认号(Acknowleggment Number)**：确认号确定了源点下一次希望从目标接收的序列号。\r\n\r\n**报头长度(Header Length)**：单位为4字节。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,72),(25,'Wireshark使用','25',1532707200,1583035238,'<!--markdown-->#### 自定义名称解析\r\n[wireshark手册](https://www.wireshark.org/docs/wsug_html_chunked/ChAppFilesConfigurationSection.html)\r\n\r\nOn Windows:\r\n- The personal configuration folder for Wireshark is the Wireshark sub-folder of that folder, i.e. %APPDATA%\\Wireshark.\r\n- The global configuration folder for Wireshark is the Wireshark program folder and is also used as the system configuration folder. \r\n\r\nOn Unix-like systems:\r\n- The personal configuration folder is $XDG_CONFIG_HOME/wireshark. For backwards compatibility with Wireshark before 2.2, if $XDG_CONFIG_HOME/wireshark does not exist and $HOME/.wireshark is present, then the latter will be used.\r\n- If you are using macOS and you are running a copy of Wireshark installed as an application bundle, the global configuration folder is APPDIR/Contents/Resources/share/wireshark. Otherwise, the global configuration folder is INSTALLDIR/share/wireshark.\r\n- The /etc folder is the system configuration folder. The folder actually used on your system may vary, maybe something like: /usr/local/etc.\r\n\r\n**ethers**\r\n\r\n    When Wireshark is trying to translate an hardware MAC address to a name, it consults the ethers file in the personal configuration folder first. If the address is not found in that file, Wireshark consults the ethers file in the system configuration folder.\r\n\r\n    Each line in these files consists of one hardware address and name separated by whitespace. The digits of hardware addresses are separated by colons (:), dashes (-) or periods(.). The following are some examples:\r\n\r\n    ff-ff-ff-ff-ff-ff    Broadcast\r\n    c0-00-ff-ff-ff-ff    TR_broadcast\r\n    00.2b.08.93.4b.a1    Freds_machine\r\n\r\n    The settings from this file are read in when a MAC address is to be translated to a name, and never written by Wireshark.\r\n    \r\n**hosts**\r\n\r\n    Wireshark uses the entries in the hosts files to translate IPv4 and IPv6 addresses into names.\r\n\r\n    At program start, if there is a hosts file in the global configuration folder, it is read first. Then, if there is a hosts file in the personal configuration folder, that is read; if there is an entry for a given IP address in both files, the setting in the personal hosts file overrides the entry in the global hosts file.\r\n\r\n    This file has the same format as the usual /etc/hosts file on Unix systems.\r\n\r\n    An example is:\r\n\r\n    # Comments must be prepended by the # sign!\r\n    192.168.0.1 homeserver\r\n\r\n    The settings from this file are read in at program start and never written by Wireshark.\r\n\r\n ',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,62),(26,'以太网权威指南','26',1534435200,1583035566,'<!--markdown--># IEEE以太网标准\r\n## IEEE标准组织\r\n### OSI模型中的IEEE子层\r\n\r\n以太网标准与OSI模型的第1层（物理层）和第2层（数据链路层）相关，所以有人将以太网标准称为**链路层标准**.为了更好地组织以太网开发规范的细节，IEEE定义了匹配OSI模型第1层和第2层的额外子层，这意味着IEEE标准包含一些比OSI模型更详细的分层。\r\n\r\n![主要的IEEE子层](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/%E4%B8%BB%E8%A6%81%E7%9A%84IEE%E5%AD%90%E5%B1%82.png \"主要的IEEE子层\")\r\n\r\nOSI数据链路层包括IEEE逻辑链路控制（LLC）和介质访问控制（MAC）子层。LLC层是IEEE定义的机制，基作用是识别以太网帧携带的数据。MAC层定义了用来随机访问以太网系统的协议。\r\n\r\nOSI物理层包括标准化以太网介质速度的IEEE子层。这些子层用来协助组织以太网规范。\r\n\r\nIEEE LLC标准独立于802.3以太网LAN标准，且不会因采用的LAN系统而变化。LLC控制领域不止面向以太网，还面向各种LAN系统，这也是LLC子层不属于IEE802.3系统规范的原因。\r\n\r\n在LLC子层之下的各个IEEE子层都是面向特定LAN技术的，这里讨论的是面向以太网的。\r\n\r\n## IEEE介质系统标识符\r\n\r\nIEEE使用缩写标识符识别多种以太网介质系统。标识符分为三部分，分别表示**速度**、**信号类型**和**物理介质信息**。\r\n\r\n### 10 Mbit/s介质系统 略\r\n\r\n### 100 Mbit/s介质系统\r\n\r\n- 100BASE-T\r\n\r\n  这是IEEE对所有100Mbit/s系统的标识符。因为这个标识符既包括光纤系统也包括双绞线系统，所以此处的“-T”有些模棱两可。\r\n  \r\n- 100BASE-X\r\n\r\n  这个标识符代表100BASE-TX介质系统和100BASE-FX介质系统。\r\n  \r\n- 100BASE-TX\r\n\r\n  这个标准描述了一个在两对5类双绞线上运行的快速以太网系统。采用基带模式，速度为100Mbit/s\r\n  \r\n- 100BASE-FX\r\n\r\n  这种快速以太网系统采用多模光纤电缆，基带模式。速度为100Mbit/s\r\n  \r\n### 1000 Mbit/s介质系统\r\n\r\n- 1000BASE-X\r\n\r\n  这个标识符描述了一个基于改自光纤通道的8B/10B块编码方案的千兆以太网介质系统。1000BASE-X介质系统包括1000BASE-SX、1000BASE-LX和1000BASE-CX。\r\n  \r\n- 1000BASE-SX\r\n\r\n  这个标识符中的S代表短波长中的“短”。\r\n  \r\n- 1000BASE-LX\r\n\r\n  这种千兆以太网采用长波长光纤介质段\r\n  \r\n- 1000BASE-T\r\n\r\n  这是IEEE对采用5类（或更好的）双绞线的1000Mbit/s千兆以太网的标识符。\r\n  \r\n### 10 Gbit/s介质系统\r\n\r\n- 10GBASE-CX4\r\n\r\n  基于短程铜轴电缆（最长15米）的10Gbit/s以太网。\r\n  \r\n- 10GBASE-T\r\n\r\n  基于无屏蔽和屏蔽双绞线电缆的10Gbit/s以太网。为了达到指定的最大距离，系统采用6A类或更好的双绞线。\r\n  \r\n- 10GBASE-SR\r\n\r\n  基于短程多模光纤的10Gbit/s以太网\r\n  \r\n- 10GBASE-LR\r\n\r\n  基于远程单模光纤电缆的10Gbit/s以太网。\r\n  \r\n### 40Gbit/s介质系统\r\n\r\n- 40GBASE-CR4\r\n\r\n  4个短程双轴铜电缆捆绑为一个单一电缆的40Gbit/s以太网。\r\n  \r\n- 40GBASE-SR4\r\n\r\n  基于4个短程多模光纤电缆5 40Gbit/s以太网。\r\n  \r\n- 40GBASE-LR4\r\n\r\n  基于一个长距离单模光纤电缆携带4个波长的40Gbit/s以太网。\r\n  \r\n### 100Gbit/s介质系统\r\n\r\n- 100GBASE-SR10\r\n\r\n- 100GBASE-LR4\r\n\r\n2003年发布的10Gbit/s以太网标准，支持在扩展6类（CAT-6A）双绞电缆上进行每秒100亿位的传输。\r\n\r\n# 以太网系统\r\n\r\n最早期的以太网采用**半双工**操作模式。半双工是指在任意时间，只有一台计算机可以在以太网信道传递信息。在半双工模式下，多台计算机使用带有冲突检测的载波侦听多路访问（CSMA/CD）介质访问控制（MAC）协议共享单个以太网信道。\r\n\r\n现今几乎所有以太网设备都直接连接到一个**全双工**模式以太网交换机接口上，不与其他设备共享以太网信道。当以太网设备连接到交换机端口时，自动协商协议会自动选择全双工模式，同时关闭CSMA/CD协议，使得链路中的两台设备都可以随时发送数据。\r\n\r\n半双工模式和全双工模式是两种形式的介质访问控制。\r\n\r\n## 以太网的四个基本元素\r\n\r\n以太网系统包括四个基本块，这四块组合成一个正常运行的以太网。\r\n\r\n- **帧**：系统中用来传递数据的一组标准化的数据位。\r\n\r\n- **介质访问控制协议**：由一组嵌在各个以太网接口的协议组成，允许以太网基站通过半双工或全双工模式访问以太网信道。\r\n\r\n- **信号组件**：可以在以太网信道发送或接收信号的标准化电子设备。\r\n\r\n- **物理介质**：在联网的计算机间传递数字以太网信号的电缆或其他硬件。\r\n\r\n### 以太网帧\r\n\r\n一帧以一组64位的**帧头**开始。帧头给10Mbit/s以太网系统的硬件和电子设备一些启动时间来意识到有帧正在传输，提醒它们做好接收数据的准备。10Mbit/s网络正是通过这种方式清清嗓子，准备开唱的。较新的以太网系统运行速度更快，使用恒定信号，不再需要帧头。不过，为了避免帧结构改变，这些系统中的帧依旧保留了帧头。\r\n\r\n帧头后是**目的地址**和**源地址**。每个地址都是独一无二的，这个48位的地址通常通常叫做硬件（物理）地址，以表明地址是分配给以太网接口的。这个地址也叫做介质访问控制（MAC）地址，这是因为以太网介质访问控制系统包括帧和帧的地址。\r\n\r\n地址域之后是一个16位的**类型**或**长度**域。通常，这个域用来标识数据采用的是哪一种高级网络协议（如TCP/IP）。这个域也可能用来携带长度信息。\r\n\r\n类型域之后便是长度为46到1500字节的**数据**。数据必须不短于46字节。这个长度保证帧信号在网络中停留的时间足以让最早的10Mbit/s半双工系统识别出来。\r\n\r\n最后，在帧的末尾是32位的**帧校验序列**（FCS）域。FCS包括一个循环冗余检验（CRC），用来对整帧数据的完整性进行检测（除去帧头、起始帧分隔符、FCS的其他部分）。接收端以太网接口可以判断该帧各位是否完整传输。\r\n\r\n### 介质访问控制协议\r\n\r\n早期的以太网系统基于CSMA/CD协议，该协议用来对共享一个信道的基站进行访问动作管理。当今大部分基站采用的都是全双工模式，该模式为基站和交换机端口提供一个专用信道。\r\n\r\n以太网传递机制支持多播，相较于将相同的帧传递给多个接收者，多播效率更高。通过一个多播地址，单个以太网帧可被多个基站接收。例如，一个提供流媒体服务的应用程序通过设置基站的以太网接口，使其不仅可以监听内置的单播地址，还可以监听指定的多播地址。这样，多个基站可以被配置为一个多播组。\r\n\r\n# 以太网帧和全双工模式\r\n\r\n现今大部分以太网链路都使用全双工模式，不过，使用双绞线10Mbit/s和100Mbit/s以太网接口仍旧支持半双工模式。\r\n\r\n## 以太网帧\r\n\r\n![以太网帧](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E7%9A%84%E6%A0%BC%E5%BC%8F.png \"以太网帧\")\r\n\r\n因为DIX基本帧和IEEE基本帧都至多有1518字节，并且拥有同样个数和长度的域，所以以太网接口既可以发送DIX基本帧，也可以发送IEEE基本帧。这些帧唯一不同之处在于内容域。\r\n\r\n### 帧头\r\n\r\n帧开头是64位的帧头域，帧头域的引入是为了帮助10Mbit/s以太网接口在实际内容到来之前同步数据流。考虑到信号在电缆系统传递存在启动延迟，帧头域允许若干字节的丢失。在10Mbit/s的系统上操作时，帧头域保护剩余帧的字节。\r\n\r\n高速以太网系统采用更复杂的机制进行信号编码，以避免信号启动损失，因此这些系统也不需要帧头保护。不过，为了保证兼容早期以太网并为帧间管理提供时间，帧头部分仍然保留。\r\n\r\n尽管两个标准对帧头位的官方定义略有不同，但DIX帧头和IEEE帧头在使用中是没有实质差异的，二者传递位的模式也是完全相同的。\r\n\r\n- DIX标准\r\n\r\n  帧头包括8个字节。帧头的前7字节由交替的0和1组成。第8字节的前6位是交替的0和1，末尾两位是统一的“1，1”。末尾两位提醒接口帧头已经结束，随后传来的将是帧的内容。\r\n\r\n- IEE标准\r\n\r\n  帧头域分为两个部分，第一部分是7字节的帧头，第二部分是1字节的起始帧分界符（SFD）。和DIX标准一样，SFD的最后两位是“1，1”。\r\n  \r\n### 目的地址\r\n\r\n每个以太网接口都有一个独一无二的48位地址，叫作该接口的**物理地址**或**硬件地址**。目的地址域长48位，可以是目的基站的接口地址，也可以是多播地址或广播地址。\r\n\r\n- DIX标准\r\n\r\n  目的地址的第一位用于区分物理地址和多播地址。如果第一位为0，那么这个地址就是一个接口的物理地址，也叫单播地址。如果第一位为1，那么此帧将被发送到一个多播地址。如果48位都是1，那么这就是一个广播地址。\r\n  \r\n- IEEE标准\r\n\r\n  IEEE 802.3标准对目的地址的第二位赋予了意义，利用其区分本地和全局管理地址。全局管理地址是制造商分配给网卡的物理地址，目的地址的第二位为0表示该地址为全局地址（DIX以太网地址都是全局管理地址）。如果因为某种原因，以太网接口是本地管理的，那么就要把目的地址的第二位设置为1。\r\n  \r\n  \r\n  >因为在出厂时，每个以太网接口都配有以太网地址，所以本地管理地址很少见。\r\n  \r\n#### 理解物理地址\r\n\r\n  以太网中，48位的物理地址由12个十六进制的数表示。这12个数两两为一组，每组8位信息。传送从最左的8位开始到最右的8位。一个字节中位的实际传送顺序是从最低位到最高位。\r\n  \r\n  也就量说，一个用十六进制字符串F0-2E-15-6C-77-9B表示的以太网地址在信道传递的字符串从左到右为：0000 1111 ... 1101 1001。\r\n  \r\n  因此，这个以十六进制0xF0开始的地址是单播地址，因为信道传送的第一位为0。\r\n  \r\n### 源地址\r\n\r\n  源地址是发送设备的物理地址。尽管它是发送设备的唯一物理地址，但是以太网MAC协议不会解析此地址。高层网络协议会利用源地址来协助解决网络故障。交换机也会使用源地址创建表格，把源地址和交换机端口联系起来。以太网基站传送的所有帧都会将基站物理地址作为源地址。\r\n  \r\n### Q标签\r\n\r\n  指802.1Q标签，这个标签也称为VLAN标签或者优先标签。指定VLAN的以太网流量只能被隶属于该VLAN的交换机端口发送或接收。\r\n  \r\n  Q标签的前两个字节是以太网类型标识符0x8100。如果一个不收发VLAN标签帧的以太网基站接收到了这种帧，该基站会把一个看上去像是类型标识符的东西看作一种未知的协议类型，并直接丢弃该帧。\r\n  \r\n### 信封前缀和后缀\r\n  TODO\r\n  \r\n### 类型/长度域\r\n\r\n- DIX标准\r\n\r\n  DIX以太网标准定义的类型域长16位，其中包括一个标识符，用来指代以太网帧数据域携带的高层协议数据类型。例如，0x0800为IP协议的标识符。\r\n  \r\n- IEEE标准\r\n\r\n  IEEE802.3将该域称为长度／类型域，域中的十六进制数值表示用何种规则使用该域。该域的第一个字节是最重要的数值。\r\n  \r\n  如果该域的数值小于或等于十进制数1500（十六进制0x5DC），那么这个域用作长度域。\r\n  \r\n  如果该域的数值大于或等于十进制数1536（十六进制0x600），那么这个域将用作类型域。\r\n  \r\n### 数据域\r\n  TODO\r\n  \r\n### FCS域\r\n\r\n  DIX帧和IEEE帧的最后一个域都是帧校验序列（FCS）域，也叫循环冗余检验（CRC）。\r\n  \r\n  接收基站接口在读取帧时会再次计算CRC，之后比较这个CRC值和帧FCS域的CRC值。如果两个值完全相同，说明信息传输过程无误，反之，网卡会丢弃该帧，同时帧错误计数器加一。\r\n  \r\n### 结束帧检测\r\n  TODO\r\n\r\n## 全双工介质访问控制\r\n\r\n全双工操作必须满足以下要求\r\n  \r\n- 介质系统必须有可同步操作、独立收发数据的路径\r\n\r\n- 任何全双工点对点链路都只连接两个基站。没有使用共享介质的连接，因此没有必要采用多路访问算法（如CSMA/CD）\r\n\r\n- 基站和网络链路必须都支持并配置为全双工操作模式。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,74),(27,'Telnet协议','27',1535731200,1583035880,'<!--markdown-->telnet选项以FF开头，用来区别有效数据。\r\n选项可以是单独封装发送，也可以封装在数据后面一起发送（区分方法：以FF开头的即选项）\r\n\r\n[参考1：TCP/IP Guide](http://www.tcpipguide.com/free/t_TelnetOptionsandOptionNegotiation.htm)\r\n\r\n[参考2：IANA Web site](https://www.iana.org/assignments/telnet-options/telnet-options.xhtml)',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,71),(28,'python3使用pandas数据处理','28',1536508800,1583035920,'<!--markdown-->Dataframe 布尔逻辑使用`&`和`|`\r\n\r\n```python\r\nnp.random.seed(0)\r\ndf = pd.DataFrame(np.random.randn(5,3), columns=list(\'ABC\'))\r\n>>> df\r\n          A         B         C\r\n0  1.764052  0.400157  0.978738\r\n1  2.240893  1.867558 -0.977278\r\n2  0.950088 -0.151357 -0.103219\r\n3  0.410599  0.144044  1.454274\r\n4  0.761038  0.121675  0.443863\r\n\r\n>>> df.loc[(df.C > 0.25) | (df.C < -0.25)]\r\n          A         B         C\r\n0  1.764052  0.400157  0.978738\r\n1  2.240893  1.867558 -0.977278\r\n3  0.410599  0.144044  1.454274\r\n4  0.761038  0.121675  0.443863\r\n\r\n\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,61),(29,'查看linux发行版名称和版本号的方法','29',1537113600,1583035969,'<!--markdown-->查看 Linux 发行版名称和版本号\r\n\r\n* ### lsb_release\r\n  > LSB（Linux Standard Base, Linux 标准库）能够打印发行版的具体信息，包括发行版名称、版本号、代号等。\r\n    \r\n    ```commandline\r\n    # lsb_release -a\r\n    No LSB modules are available.\r\n    Distributor ID: Ubuntu\r\n    Description: Ubuntu 16.04.3 LTS\r\n    Release: 16.04\r\n    Codename: xenial\r\n    ```\r\n  \r\n* ### /etc/*-release 文件\r\n  >release 文件通常被视为操作系统的标识。在 /etc 目录下放置了很多记录着发行版各种信息的文件，每个发行版都各自有一套这样记录着相关信息的文件。\r\n  \r\n    ```commandline\r\n    # cat /etc/issue\r\n    # cat /etc/issue.net\r\n    # cat /etc/os-release\r\n    ```\r\n    \r\n* ### uname 命令\r\n  >uname（unix name 的意思） 是一个打印系统信息的工具，包括内核名称、版本号、系统详细信息以及所运行的操作系统等等。\r\n\r\n* ### /proc/version 文件\r\n  >这个文件记录了 Linux 内核的版本、用于编译内核的 gcc 的版本、内核编译的时间，以及内核编译者的用户名。\r\n  \r\n* ### dmesg 命令\r\n  >dmesg（display message, 展示信息 或 driver message, 驱动程序信息）是大多数类 Unix 操作系统上的一个命令，用于打印内核的消息缓冲区的信息。\r\n  \r\n    ```commandline\r\n    # dmesg | grep \"Linux\"\r\n    [ 0.000000] Linux version 4.12.14-300.fc26.x86_64 ([email protected]) (gcc version 7.2.1 20170915 (Red Hat 7.2.1-2) (GCC) ) #1 SMP Wed Sep 20 16:28:07 UTC 2017\r\n    [ 0.001000] SELinux: Initializing.\r\n    [ 0.001000] SELinux: Starting in permissive mode\r\n    [ 0.470288] SELinux: Registering netfilter hooks\r\n    [ 0.616351] Linux agpgart interface v0.103\r\n    [ 0.630063] usb usb1: Manufacturer: Linux 4.12.14-300.fc26.x86_64 ehci_hcd\r\n    [ 0.688949] usb usb2: Manufacturer: Linux 4.12.14-300.fc26.x86_64 ohci_hcd\r\n    [ 2.564554] SELinux: Disabled at runtime.\r\n    [ 2.564584] SELinux: Unregistering netfilter hooks\r\n    ```\r\n    \r\n参考文档：[https://linux.cn/article-9586-1.html](https://linux.cn/article-9586-1.html)',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,74),(30,'linux系统设置代理以及火狐firefox设置代理','30',1538582400,1583036007,'<!--markdown-->\r\n#### centos7设置全局代理\r\n```commandline\r\n在/etc/profile最后添加\r\nproxy=http://proxy_ip:port\r\nhttp_proxy=$proxy\r\nhttps_proxy=$proxy\r\nHTTP_PROXY=$proxy\r\nHTTPS_PROXY=$proxy\r\nexport http_proxy https_proxy HTTP_PROXY HTTPS_PROXY\r\n\r\n保存后执行立即生效:\r\nsorce /etc/profile \r\n```\r\n\r\n#### 代理自动配置(proxy auto-config) PAC\r\n- 安装genpac\r\n    \r\n    ```sh\r\n    sudo pip install genpac\r\n    pip install --upgrade genpac\r\n    ```\r\n\r\n- 调用在线gfwlist列表生成本地autoproxy.pac文件\r\n```commandline\r\ngenpac --pac-proxy \"SOCKS5 127.0.0.1:7070\" --output=\"autoproxy.pac\" \r\n```\r\n\r\n- 在火狐中使用autoproxy.pac\r\n\r\n#### 火狐设置代理\r\n在设置页（about:preferences）找到网络代理\r\n\r\n如果需要，在（about:config）有更加详细的设置\r\n\r\n比如：force-generic-ntlm-v1',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,76),(31,'Excel表格的一些使用技巧','31',1540310400,1587222696,'<!--markdown-->* 合并字符串\r\n\r\n    excel中，concatenate函数可将多个字符串合并为一个文本字符串。也可以使用连接符号(&)运算符代替该函数，例如，=A1&B1\r\n    \r\n* 筛选查找\r\n    \r\n    VLOOKUP(lookup_value,table_array,col_index_num, 0)\r\n    \r\n    在指定的范围内查找某个值，查找方向是垂直方向，并且在每行的第一列中查找。最终会返回一个单元格中的值。\r\n    \r\n    `lookup_value`：查找的值，可以是单元格的引用\r\n    \r\n    `table_array`：范围\r\n    \r\n    `col_index_num`：指定返回哪列的值，从1开始\r\n    \r\n# 单元格引用\r\n\r\n`=B2` 是引用单元格B2的值，拉动后它自动会增长\r\n\r\n`=Sheet2!B2` 引用表格Sheet2中的内容\r\n\r\n`=$B2` 左右拉动会自动增长，上下方向是绝对引用，上下拉动时不会变化\r\n\r\n`=$B$2` 单元格的绝对引用，不会变化\r\n\r\n`=\"文本中引用\"&B2&\"文本中引用结束\"` 在一个句子中引用其他单元格的内容\r\n    \r\n# 逻辑运算\r\n\r\n	IFERROR(value,value_if_error)\r\n\r\n# 单元格自定义格式的规则\r\n\r\n| 占位符 | 注释 |\r\n|-------|------|\r\n| #     | 数字占位符。只显有意义的零而不显示无意义的零。<br/>小数点后数字如大于”#”的数量，则按”#”的位数四舍五入。|\r\n| 0     | 数字占位符。如果单元格的内容大于占位符，<br/>则显示实际数字，如果小于点位符的数量，则用0补足。 |\r\n| ？    | 数字占位符。在小数点两边为无意义的零添加空格，<br/>以便当按固定宽度时，小数点可对齐，另外还用于对不等到长数字的分数 |\r\n| @     | 文本占位符，如果只使用单个@，作用是引用原始文本。<br/>要在输入数字数据之后自动添加文本，使用自定义格式为：”文本内容”@；<br/>要在输入数字数据之前自动添加文本，使用自定义格式为：@”文本内容”。<br/>@符号的位置决定了Excel输入的数字数据相对于添加文本的位置。<br/>如果使用多个@，则可以重复文本。 |\r\n\r\n参考链接：https://wenku.baidu.com/view/f36ae79c90c69ec3d4bb7575?pcf=2\r\n\r\n# 怎么设置excel打印每页都有表头标题\r\n\r\n`页面布局`->`打印标题`->在`页面设置`界面中选择工作表->设置`顶端标题行`\r\n\r\n# Excel表格如何设置分页打印\r\n\r\n`视图`->`工作簿视图`->`分布预览`->拖动蓝色线条设置\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,66),(32,'TCP/IP路由技术 002-静态路由、动态路由选择协议','32',1542470400,1583036185,'<!--markdown-->\r\n路由表又叫路由选择信息库（RIB）\r\n\r\n在数据库中的每个路由表项最少包括下面两个项目：\r\n* **目标地址**\r\n* **指向目标的指针**————指针指向路由器的直连目标网络或直连网络内的另一台路由器地址，或者是到这个链路的本地接口\r\n\r\n如果数据包的目的地址不能匹配到任何一条路由表项，那么数据包将被丢弃，同时一个“目标网络不可达”的ICMP消息将会被发送给源地址。\r\n\r\n如果把静态路由指向一个广播型出站接口，而不是下一跳地址，路由器会认为该网络是直连网络，当路由器向直连网络内转发数据包时，会触发ARP请求，假如直连网络内存在一台ARP代理，路由器可能会占用大量的ARP缓存。\r\n\r\n##### 度量值和管理距离\r\n\r\n如果路由器正在运行多个路由选择协议，并从每个协议都学习到一条到达相同目标网络的路由，那么应该选择哪一条路由呢？答案是管理距离。管理距离被看作是一个可信度测度，管理距离越小，协议的可信度越高。\r\n\r\n|路由源|管理距离|\r\n|-----|------|\r\n|直连接口|0|\r\n|静态路由|1|\r\n|EIGRP汇总路由|5|\r\n|外部BGP|20|\r\n|EIGRP|90|\r\n|IGRP|100|\r\n|OSPF|110|\r\n|IS-IS|115|\r\n|RIP|120|\r\n|EGP|140|\r\n|外部EIGRP|170|\r\n|内部BGP|200|\r\n|未知|255|\r\n\r\n当有多条路径到达相同目标网络时，路由器需要一种机制来计算最优路径，度量（metric）可以按照最好到最坏对路由进行等级划分。\r\n\r\n度量值指明了路径（同种路由协议？）的优先权，而管理距离指明了发现路由方式（路由协议）的优先权。\r\n\r\n## 动态路由选择协议\r\n\r\n### 路由选择协议基础\r\n\r\n所有路由选择协议都是围绕一种算法而构建的。通常，一种算法是一个逐步解决问题的过程。一种路由算法至少应指明以下内容：\r\n\r\n- 向其他路由器传送网络可达性的过程\r\n- 从其他路由器接收可达性信息的过程\r\n- 基于现有可达性信息决策最优路由的过程以及在路由表中记录这些信息的过程\r\n- 响应、修正和通过网络中拓扑变化的过程\r\n\r\n对所有路由选择协议来说，几个共同的问题是路径决策、度量、收敛和负载均衡。\r\n\r\n#### 路径决策\r\n\r\n路由器需要向其他路由器发送自己的网络信息、选择到达目标网络的最优路径、避免路由环路等。\r\n\r\n#### 度量\r\n\r\n当有多条路径到达相同目标网络时，路由器需要一种机制来计算最优路径，度量（metric）可以按照最好到最坏对路由进行等级划分。不同的路由协议使用不同的度量。\r\n\r\n- 跳数\r\n\r\n  跳数度量可以简单地记录路由器跳数。假设仅使用跳数作为度量，那么最优路径就是跳数最少的路径。\r\n  \r\n- 带宽\r\n\r\n  带宽度量将会选择高带宽路径，而不是低带宽路径。然而带宽本身可能不是一个好的度量。有时一条空闲的低带宽链路可能比拥堵的高带宽链路更好。\r\n  \r\n- 负载\r\n\r\n  负载度量反应了流量占用沿途链路带宽的比重。最优的路径应该是负载最低的路径。路径上的负载会发生变化，因而度量也会跟着变化，如果度量变化过于频繁，路由波动（最优路径频繁变化）可能就发生了。路由波动会对路由器的CPU、数据链路的带宽和全网稳定性产生负面影响。\r\n  \r\n- 时延\r\n\r\n  时延（Delay）是度量数据包经过一条路径所花费的时间。时延不仅要考虑链路时延，而且还要考虑路由器的处理时延和队列时延等因素。\r\n  \r\n- 可靠性\r\n\r\n  可靠性(Reliability)度量是用来测量链路在某种情况下发生故障的可能性。\r\n  \r\n- 代价\r\n\r\n  由管理员设置的代价（Cost）度量可以反应更优或更差路由。\r\n\r\n#### 距离失量路由选择协议\r\n\r\n路由是以失量（距离、方向）的方式被通告出去的。\r\n\r\n- 定期更新\r\n\r\n- 广播更新\r\n\r\n- 全路由表选择更新\r\n\r\n- 依照传闻进行路由选择mus\r\n\r\n- 路由失效计时器\r\n    \r\n    路由表中的每个表项设置路由失效计时器，如果经过几个周期没有收到路由更新，把该路由标记为不可达。\r\n    \r\n- 水平分隔\r\n\r\n    **简单水平分隔**：从某接口学到的路由不能从该接口发送出去\r\n    \r\n    **毒性逆转水平分隔**：从某接口学到的路由会从该接口发送出去，但是被标记为不可达（度量值无穷大）。\r\n    \r\n- 计数到无穷大\r\n    \r\n    设置一个最大跳数，达到该跳数的路由被认为不可达。\r\n    \r\n- 触发更新（快速更新）\r\n    \r\n    如果一个度量变好或变坏，那么路由器将立即发送更新信息，而不等更新计时器超时。\r\n    \r\n- 抵制计时器\r\n\r\n    如果到一个目标的距离增加，那么路由器将为该路由设置抵制计时器，直到计时器超时，路由器才可以接受有关此路由的更新信息。\r\n\r\n- 异步更新\r\n    \r\n    在更新周期中加入随机时间或定时抖动作为偏移。\r\n    \r\n#### 链路状态路由选择协议\r\n\r\n- 邻居\r\n    \r\n- 链路状态泛洪扩散\r\n\r\n    - 序列号\r\n    \r\n    - 老化\r\n    \r\n- 链路状态数据库\r\n\r\n- SPF 算法\r\n\r\n- 区域',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,70),(33,'TCP/IP路由技术 003-OSPF','33',1542816000,1587222786,'<!--markdown-->[RFC2328-OSPFv2](https://tools.ietf.org/html/rfc2328)\r\n\r\n[Cisco-有编号和无编号的接口](https://www.cisco.com/c/en/us/support/docs/ip/hot-standby-router-protocol-hsrp/13786-20.html)\r\n\r\n## OSPF的基本原理与实现\r\n\r\n1. 宣告OSPF的路由器从所有启动OSPF协议的接口上发出Hello数据包。如果两台路由器共享一条公共数据链路，并且能够相互成功协商它们各自Hello数据包中所指定的某些参数，那么它们就成为了邻居（Neighbor）。\r\n\r\n2. 邻接关系（Adjacency），它是在一些邻居路由器之间构成的。\r\n\r\n3. 每一台路由器都会在所有形成邻接关系的邻居之间发送链路状态通告（Link State Advertisement， LSA）。LSA描述了路由器所有的链路、接口、路由器的邻居以及链路状态信息。\r\n\r\n4. 每一台收到从邻居路由器发出的LSA的路由器都会把这些LSA记录在它的链路状态数据库中，并且发送一份LSA的拷贝给该路由器的其他所有邻居。\r\n\r\n5. 通过LSA泛洪扩散到整个区域，所有的路由器都会形成同样的链路状态数据库。\r\n\r\n7. 每一台路由器都会使用SPF算法构建出自己的路由表。\r\n\r\n当链路状态数据库已经同步，邻居之间交换Hello数据包保活，并且每隔30分钟重传一次LSA。如果这期间有新的接口宣告到OSPF域中，不会立即产生LSA,需要等到和其他LSA一起发送。\r\n\r\n### 邻居和邻接关系\r\n\r\n在发送任何LSA之前，OSPF路由器都必须首先发现它们的邻居路由器并建立起邻接关系，并不是所有的邻居路由器都会成为邻接关系。\r\n\r\nOSPF路由器利用Hello数据包通告它的路由器ID来开始建立邻居关系\r\n\r\nHello协议的目的：\r\n    \r\n- 它是发现邻居路由器的方法\r\n- 在两台路由器成为邻居之前，需要通告这两台路由器必须相互认可的几个参数\r\n- Hello数据包在邻居路由器之间担当keeplive的角色\r\n- 它确保了邻居路由器之间的双向通信\r\n- 它用来在一个广播网络或非广播多路访问（NBMA）网络上选取指定路由器（Designated Router, DR）和备份指定路由器（Backup Designated Router, BDR）\r\n\r\n宣告OSPF的路由器周期性的从启动OSPF协议的每一个接口上发送Hello数据包，该周期称为Hello时间间隔（HelloInterval），它的配置是基于路由器的每一个接口的。\r\n\r\n如果一台路由器在一个称为路由器无效时间间隔（RouterDeadInterval）的时间内还没有收到来自邻居的Hello数据包，那么它将宣告它的邻居无效。\r\n\r\n每一个Hello数据包都包含以下信息：\r\n\r\n- 始发路由器的路由器ID（RouterID）\r\n- ***始发路由器的象区域ID（AreaID）**\r\n- ***始发路由器接口的地址掩码**\r\n- ***始发路由器接口的认证类型和认证信息**\r\n- ***始发路由器接口的Hello间隔**\r\n- ***始发路由器接口的路由器无效时间间隔**\r\n- 路由器的优先级\r\n- 指定路由器（DR）和备份指定路由器（BDR）\r\n- ***标识可选性能的5个标记位**。E-bit选项代表OSPF的ExternalRoutingCapability，所有非stub区域的路由器都应置为1。\r\n  \r\n- 始发路由器的所有有效邻居的路由器ID\r\n\r\n如果带*的参数不匹配，那么该数据包将被丢弃，而且无法成为邻居（不会创建发送方的邻居数据结构）。\r\n\r\n如果路由器A收到了一个有效的Hello数据包，并在这个Hello数据包中发现了自己的路由器ID，那么路由器A就认为是双向通信（two-way communication）建立成功了。路由器A会立即向对方单播发送一个Hello包。\r\n\r\n并不是所有的邻居路由器都会成为邻接关系，一个邻接关系的形成依赖于这两台邻居路由器所连接的网络类型。另外，网络类型也影响OSPF数据包传送的方式。\r\n\r\n如果**数据库描述包中的MTU值**大于路由器接收端口的MTU值，这个数据库描述包会被丢弃（译注：RFC中用词是rejected）。邻接关系也无法建立（会卡在Excheange阶段）。\r\n\r\n#### 网络类型\r\n\r\nOSPF协议定义了5种网络类型：\r\n1. 点到点网络（point-to-point）\r\n2. 广播型网络（broadcast）\r\n3. 非广播多路访问（NBMA）网络\r\n4. 点到多点网络（point-to-multipoint）\r\n5. 虚链路（virtual links）\r\n\r\n- 点到点网络\r\n  \r\n  在点到点网络上的有效邻居总是可以形成邻接关系，OSPF数据包的目的地总是224.0.0.5，这个组播地址称为AllSPFRouters。\r\n  \r\n- 广播型网络\r\n  \r\n  会选举一台指定路由器和一台备份指定路由器。DR和BDR的OSPF数据包都发送到224.0.0.5。\r\n  \r\n  该类型网络上其他所有路由器的Hello数据包是以组播方式发送到AllSPFRouters（224.0.0.5），而链路状态更新数据包和链路状态确认数据包是发送到224.0.0.6，这个组播地址称为AllDRouters。\r\n  \r\n#### 指定路由器与备份指定路由器\r\n\r\n指定路由器是路由器接口的特性，而不是整个路由器的特性。\r\n\r\n网络中的每一台路由器都会与DR、BDR形成邻接关系，路由器的每个多点访问接口都有一个路由器的优先级（0～255），0优先级的路由器不能参与选举，也就是说不能成为DR或BDR。\r\n\r\n#### 选举过程\r\n\r\n选举过程概述：当一台OSPF路由器active并去发现它的邻居时，它将去检查有效的DR和BDR，如果DR和BDR存在的话，这台路由器会接受已经存在的DR和BDR；如果BDR不存在，将执行一个选举过程，选出具有最高优先级的路由器作为BDR。如果DR不存在，那么BDR路由器将被选为DR，然后再执行一个选举过程选取BDR路由器。\r\n\r\n选举是非抢占的\r\n\r\n一旦DR和BDR路由器选举成功，其他的路由器（DRothers）将只和DR及BDR形成邻接关系。所有的路由器将继续以组播方式发送Hello数据包到AllSPFRouters（224.0.0.5）,因此它们能够跟踪它们的邻居路由器。但是DRothers只以组播方式发送更新数据包到AllDRouters（224.0.0.6）。只有DR和BDR去侦听这个地址，而DR路由器将使用224.0.0.5泛洪扩散更新数据包到DRothers。\r\n\r\nDR可以看作是一个虚拟的节点\r\n\r\n假设路由器X准备计算一个网络中的DR和BDR，它会检查网络中与它建立双向通信的邻居列表，这个列表就是路由器X在这个网络中状态高于2-way的邻居集合。路由器X自身也包含在这个列表中。去除列表中那些没有资格选举DR的路由器（优先级为0的路由器）。对列表中剩余的路由器执行以下步骤：\r\n\r\n(1) 记录当前网络中DR和BDR的值。\r\n\r\n(2) 根据下面的步骤为网络计算新的BDR。\r\n\r\n#### OSPF接口数据结构\r\n\r\n- Type\r\n\r\n  点到点（point-to-point，PTP）, 广播（broadcast）, 非广播多路访问（NBMA）, 点到多点（Point-to-MultiPoint）, 虚链路（virtual link）中的一种。\r\n  \r\n- State\r\n\r\n  接口的功能状态，状态确定是否允许在接口上形成完全的邻接。状态按照接口状态机规则变化。\r\n\r\n- IP interface address / mask\r\n\r\n- Area ID\r\n\r\n- HelloInterval\r\n\r\n  这个接口发送两个Hello报文之间间隔的时间（秒）。接口会把这个时间放在Hello报文中通告出去。\r\n  \r\n- RouterDeadInterval\r\n\r\n  不再收到邻居的Hello后，经过多少秒会宣布邻居Down。接口会把这个时间放在Hello报文中通告出去。\r\n  \r\n- InfTransDelay\r\n\r\n  这个接口发送LSU报文需要的大概时间（秒），在发送之前，LSU中的每条LSA都要把老化时间（age）加上这个值。\r\n  \r\n- Router Priority\r\n\r\n  选举DR/BDR用，越大优先级越高。接口会把这个值放在Hello报文中通告出去。\r\n  \r\n- Hello Timer\r\n\r\n  用来周期性发送Hello报文的计时器。计时时间为HelloInterval秒。\r\n  \r\n- Wait Timer\r\n\r\n  计时结束后接口会退出Waiting状态，加入DR/BDR选举过程中。计时时间为RouterDeadInterval秒。\r\n  \r\n- List of neighboring routers\r\n\r\n  连接这个网络的所有路由器列表，按照Hello协议形成。\r\n  \r\n- DR / BDR\r\n\r\n  指定路由器（Designated Router）和备份指定路由器（Backup Designated Router）。初始值都是0.0.0.0，意味着网络中没有DR/BDR。\r\n  \r\n- Interface output cost(S)\r\n\r\n- RxmtInterval\r\n\r\n  重传OSPF数据包所需要的时间\r\n  \r\n- Autype / Authentication key\r\n  \r\n  \r\n\r\n#### OSPF接口状态机\r\n\r\n参考：[RFC2328 - OSPFv2 - 9.1节](https://tools.ietf.org/html/rfc2328#page-68)\r\n\r\n                                  +----+   UnloopInd   +--------+\r\n                                  |Down|<--------------|Loopback|\r\n                                  +----+               +--------+\r\n                                     |\r\n                                     |InterfaceUp\r\n                          +-------+  |               +--------------+\r\n                          |Waiting|<-+-------------->|Point-to-point|\r\n                          +-------+                  +--------------+\r\n                              |\r\n                     WaitTimer|BackupSeen\r\n                              |\r\n                              |\r\n                              |   NeighborChange\r\n          +------+           +-+<---------------- +-------+\r\n          |Backup|<----------|?|----------------->|DROther|\r\n          +------+---------->+-+<-----+           +-------+\r\n                    Neighbor  |       |\r\n                    Change    |       |Neighbor\r\n                              |       |Change\r\n                              |     +--+\r\n                              +---->|DR|\r\n                                    +--+\r\n                                    \r\n##### 接口状态切换的事件\r\n\r\n- **InterfaceUP**    更低级的协议检测到网络接口是可操作的，这会把接口移出Down状态。\r\n\r\n- **WaitTimer**    Wait计时器超时，表明Waiting周期结束，在这之后才能选举DR或BDR。\r\n\r\n- **BackupSeen**    路由器检测到网络中存在或不存在BDR。这通过两种方式完成：从邻居接收到的Hello数据包中声明邻居自己是BDR，或者从邻居接收到Hello数据包中声明邻居自己是DR，并且没有BDR。无论哪种情况，前提都是需要和邻居建立双向通信关系。这个事件标志着Waiting状态的结束。\r\n\r\n- **NeighborChange**    指与接口建立双向关系的邻居集合发生了变化。DR和BDR需要重新选举。下面的邻居变化会引起NeighbroChange事件：\r\n\r\n  - 与一个邻居建立了双向通信关系。也就是说，邻居转为2-way状态了。\r\n  \r\n  - 与一个邻居不再是双向通信关系了。也就是说，邻居转为Init或更低的状态了。\r\n  \r\n  - 一个双向关系的邻居声明邻居自己是DR或BDR。这可以通过邻居的Hello数据包发现。\r\n  \r\n  - 一个双向关系的邻居不再声明邻居自己是DR或BDR。这也是通过邻居的Hello数据包发现。\r\n  \r\n  - 双向关系邻居的路由器优先级发生了变化。这也是通过邻居的Hello数据包发现。\r\n  \r\n - **LoopInd**    通过低层的协议发现接口是LoopBack的。\r\n \r\n - **UnloopInd**    通过低层的协议发现接口不再是LoopBack的。\r\n \r\n - **InterfaceDown**    通过低层的协议发现接口不可用，不管接口是什么状态，都会直接把接口转为Down状态。\r\n\r\n#### OSPF邻居数据结构\r\n\r\n- State\r\n\r\n  邻居的功能状态，按照邻居状态机规则变化。\r\n  \r\n- Inactivity Timer\r\n  \r\n  这是一个时长为RouterDeadInterval的计时器，只要从邻居收到一个Hello数据包，该计时器就会被重置。如果计时器超时将宣告邻居失效。\r\n  \r\n- Master/Slave\r\n\r\n  在ExStart状态下，邻居之间会协商master/slave。当两个邻居交换数据库时，msaster发送第一个数据库描述包，slave只允许回应master的数据库描述包。\r\n  \r\n- DD Sequence Number\r\n  \r\n  当前正在向邻居发送的数据库描述序列号。\r\n  \r\n- Last received Database Description packet\r\n  \r\n  最后收到的数据库描述包的 Initialize位，More位，Master/Slave位和可选项位，以及数据库描述包的序列号。用来确定下一个收到的数据库描述包是否重复。\r\n  \r\n- Neighbor ID\r\n\r\n  邻居路由器的ID，该値是从邻居的Hello数据包中学习到的，而在virtual adjacency中是手工配置。\r\n  \r\n- Neighbor Priority\r\n  \r\n  邻居路由器的路由器优先级。包含在邻居的Hello数据包中，用来选举DR和BDR。\r\n  \r\n- Neighbor IP address\r\n\r\n  邻居路由器的接口IP，当OSPF数据包以单播方式发送给邻居时，这个IP就是目的地址。\r\n  \r\n- Neighbor Options\r\n  \r\n  邻居路由器支持的一些可选的OSPF功能\r\n  \r\n- Neighbor\'s Designated Router\r\n\r\n  邻居认为的DR路由器\r\n  \r\n- Neighbor\'s Backup Designated Router\r\n\r\n  邻居认为的BDR路由器\r\n  \r\n- Link state retransmission list\r\n  \r\n  邻接关系建立后，已经泛洪出去但还没有得到确认的LSA的集合。当LSA还没有被确认或邻接关系还没破坏的时候，LSA将每经过RxmtIntrval的时间就重传一次。\r\n  \r\n- Database summary list\r\n\r\n  链路状态数据库组成的LSA的列表，在邻居处于Exchange状态时，这个列表会发送给邻居。\r\n  \r\n- Link state request list\r\n\r\n  为了同步链路状态数据库，需要从邻居接收哪些LSA的列表。这个列表在收到数据库描述数据包时被创建，然后路由器发送LSR给邻居。接收到期待的LSU时这个列表会减小，最终为空列表。\r\n                                    \r\n#### OSPF邻居状态机\r\n\r\n参考：[RFC2328 - OSPFv2 - 10节](https://tools.ietf.org/html/rfc2328#page-80)\r\n  \r\n                                   +----+\r\n                                   |Down|\r\n                                   +----+\r\n                                     |\\\r\n                                     | \\Start\r\n                                     |  \\      +-------+\r\n                             Hello   |   +---->|Attempt|\r\n                            Received |         +-------+\r\n                                     |             |\r\n                             +----+<-+             |HelloReceived\r\n                             |Init|<---------------+\r\n                             +----+<--------+\r\n                                |           |\r\n                                |2-Way      |1-Way\r\n                                |Received   |Received\r\n                                |           |\r\n              +-------+         |        +-----+\r\n              |ExStart|<--------+------->|2-Way|\r\n              +-------+                  +-----+\r\n\r\n              Figure 12: Neighbor state changes (Hello Protocol)\r\n\r\n                                  +-------+\r\n                                  |ExStart|\r\n                                  +-------+\r\n                                    |\r\n                     NegotiationDone|\r\n                                    +->+--------+\r\n                                       |Exchange|\r\n                                    +--+--------+\r\n                                    |\r\n                            Exchange|\r\n                              Done  |\r\n                    +----+          |      +-------+\r\n                    |Full|<---------+----->|Loading|\r\n                    +----+<-+              +-------+\r\n                            |  LoadingDone     |\r\n                            +------------------+\r\n\r\n            Figure 13: Neighbor state changes (Database Exchange)\r\n                \r\n- Down\r\n\r\n- Init\r\n\r\n  接收到了邻居的Hello报文，但双向通信还没建立（如：路由器没有出现在邻居的Hello报文中）。\r\n  \r\n- 2-Way\r\n\r\n  双向通信已建立。\r\n  \r\n- ExStart\r\n\r\n  在这一状态下，邻居之间会建立主/从关系，并确定数据库描述数据包的序列号。\r\n  \r\n- Exchange\r\n\r\n  在这一状态下下，路由器会向它的邻居发送数据库描述包，每个数据库描述包都有个序列号，邻居都要对这个包发送确认。同时，路由器也会发送链路状态请求数据包（LSR）给邻居，用来请求最新的LSA。\r\n  \r\n- Loading\r\n\r\n  在这一状态下下，路由器会发送链路状态请求数据包（LSR）给邻居，用来请求那些在Exchange状态下发现但还没有收到的最新的LSA。\r\n  \r\n- Full\r\n\r\n  在这一状态下下，邻接关系已完全建立。邻接关系会出现在Router-LSAs和Network-LSAs中。\r\n  \r\n#### 建立邻接关系\r\n\r\n建立邻接关系的过程中，OSPF使用3种数据包类型：\r\n\r\n- 数据库描述数据包（类型2）\r\n\r\n- 链路状态请求数据包（类型3）\r\n\r\n- 链路状态更新数据包（类型4）\r\n\r\n在数据库描述数据包中有3个标记位用来管理邻接关系的建立过程：\r\n\r\n- I位（Initial bit），当需要指明所发送的是第一个数据库描述数据包时，该位设置为1\r\n\r\n- M位（More bit），当需要指明所发送还不是最后一个数据库描述数据包时，该位设置为1\r\n\r\n- MS位（Master/Slave bit）， 当数据库描述数据包始发于一个主路由器时，该位设置为1\r\n\r\n当两台路由器在ExStart状态开始协商主/从关系时，它们都将通过发送一个MS位置为1的空的数据库描述数据包来宣称自己是“主”路由器。这两个数据库描述数据包的数据库描述序号是由路由器根据当时使用到的序列号确定的。具有较低路由器ID的邻居路由器将成为“从”路由器，并且回复一个MS为0的数据库描述数据包——这个数据库描述数据包的序列号设置为“主”路由器的序列号，同时，这个数据库描述数据包也将是第一个携带LSA摘要信息的数据包。当主/从关系协商完成后，邻居状态也将转换到Exchange状态。\r\n\r\n“主”路由器可以产生新的数据库描述序列号，“从”路由器只能使用“主”路由器产生的序列号，因此当“主”路由器描述完自己的链路状态，而“从”路由器还没有描述完时，“主”路由器会发送空的链路状态描述数据包，让“从”路由器有链路状态数据库序列号可以用。\r\n\r\n#### 泛洪扩散\r\n\r\n因为完全相同的链路状态数据库是正确操作OSPF的前提，因此LSA的泛洪扩散必须可靠的。\r\n\r\n##### 可靠的泛洪扩散： 确认\r\n\r\n 对于可靠的泛洪扩散来讲，每一个单独传送的LSA都必须被确认。确认分为隐式确认（Implicit Acknowledgment）或显式确认（Explicit Acknowledgment）。\r\n \r\n - **隐式确认**\r\n   \r\n   邻居可以通过向始发更新数据包的路由器回送包含那个LSA的拷贝信息的更新数据包，来作为对所接收的LSA的隐式确认。当邻居正打算向始发路由器发送更新数据包的时候，隐式确认比显式确认更有效。\r\n   \r\n - **显式确认**\r\n \r\n   指通过发送一个链路状态确认数据包来确认收到LSA。而且可以使用单个链路状态确认数据包来确认多个LSA。链路状态确认数据包只需要携带LSA的头部信息。\r\n   \r\n确认可以是有时延的或直接的。\r\n\r\n##### 可靠的泛洪扩散：序列号、校验和、老化时间\r\n\r\nOSPF使用线性的序列号空间和32位有符号的序列号，序列号的大小从InitialSequenceNumber（0x80000001）到MaxSequenceNumber（0x7fffffff）。当一台路由器始发一条LSA通告时，它将设置这个LSA的序列号为InitialSequenceNumber。每当这台路由器产生该LSA的一个新实例时，该路由器会将它的序列号增加1。如果LSA的序列号达到最大值且又需要创建这个LSA的一个新实例时，路由器就设置现有LSA的老化时间为MaxAge，并且重新泛洪扩散到所有的邻接节点来清除老的LSA。一旦所有的邻接邻居确认过这个老的LSA后，也就可以泛洪扩散这个含有InitialSequenceNumber序列号的LSA了。\r\n\r\n校验和是一个16位整数。计算除了Age字段外的LSA其他部分，驻留在链路状态数据库中的LSA每隔5min将计算一次校验和。\r\n\r\n老化时间（Age）是一个用来指明LSA的生存时间的16位无符号整数，以秒为单位。一台路由器在始发一个LSA时，它就把老化时间设置为0,而当泛洪扩散的LSA经过一台路由器时，LSA的老化时间就会增加InfTransDelay秒。当LSA驻留在路由器的数据库中时，LSA的老化时间同样也会增大。\r\n\r\n### 区域（Area）\r\n\r\nOSPF协议选用区域，可以减小链路状态数据库的大小，降低对路由器内存的消耗；链路状态数据库的减小也降低了路由器处理LSA时对CPU的消耗；LSA泛洪扩散也被限制在一个区域里面了。\r\n\r\n区域是通过一个32位的区域ID来识别的。区域ID可以表示为一个十进制数字，也可以表示为一个点分十进制。\r\n    \r\n    0.0.0.16      = 16*256^0 = 16\r\n    0.0.1.15      = 1*256^1 + 15*256^0 = 271\r\n    192.168.30.29 = 192*256^3 + 168*256^2 + 30*256^1 + 29*256^0 = 3232243229\r\n    \r\nOSPF定义了下面3种与区域相关的通信量的类型：\r\n\r\n- **域内通信量（Intra-Area Traffic）**\r\n  \r\n  单个区域内的路由器之间交换的数据包构成的通信量\r\n  \r\n- **域间通信量（Inter-Area Traffic）**\r\n\r\n  不同区域的路由器之间交换的数据包构成的通信量\r\n  \r\n- **外部通信量（External Traffic）**\r\n\r\n  OSPF域内的路由器和其他路由选择域的路由器之间交换的数据包构成的通信量\r\n  \r\n区域0是为骨干区域保留的区域ID号。骨干区域（Backbone Area）的任务是汇总每一个区域的网络拓扑到其他所有的区域。正是由于这个原因，所有的域间通信量都必须通过骨干区域，非骨干区域之间不能直接交换数据包。\r\n\r\n#### 路由器的类型\r\n\r\n- **内部路由器（Internal Router）**\r\n\r\n  是指所有接口都属于同一个区域的路由器\r\n  \r\n- **区域边界路由器（Area Border Routers，ABR）**\r\n\r\n  是指连接一个或者多个区域到骨干区域的路由器，并且这些路由器会作为域间通信量的路由网关。\r\n  \r\n- **骨干路由器（Backbone Router）**\r\n\r\n  是指至少有一个接口是和骨干区域相连的路由器。\r\n  \r\n- **自主系统边界路由器（Autonomous System Boundary Router，ASBR）**\r\n\r\n  可以认为是OSPF域外部通信量进入OSPF域的网关路由器，ASBR路由器是用来把从其他路由选择协议学习到的路由，通过路由选择重分配的方式注入到OSPF域的路由器。一台ASBR路由器可以是位于OSPF域内部的任何路由器。\r\n  \r\n#### 分段区域\r\n\r\n分段区域（Partitioned area）是指由于链路失效而使一个区域的一个部分和其他部分隔离开来的情形\r\n\r\n#### 虚链路\r\n\r\n虚链路（Virtual link）是指一条通过一个非骨干区域连接到骨干区域的链路。\r\n\r\n### 链路状态数据库\r\n\r\n当LSA在路由器的链路状态数据库中，它们的老化时间是增大的，如果达到了最大生存时间，那么它们将从OSPF域中清除掉，为了防止正常的LSA达到最大生存周期而被清除掉，每隔30min（LSRefreshTime）始发这条LSA的路由器就将泛洪扩散这条LSA的一个新拷贝。这种机制就是链路状态重刷新（Link state refresh）。\r\n\r\n#### LSA的类型\r\n\r\n由于OSPF定义了多种路由器的类型，因而定义多种LSA通告的类型也是必要的。\r\n\r\n- **路由器LSA（Router LSA），类型： 1**\r\n\r\n  每个路由器都会在它属于的每个区域上产生路由器LSA，每个区域的路由器LSA都列出了所有连接到该区域的链路或接口。这个LSA只会在始发它们的区域内部进行泛洪扩散。\r\n  \r\n- **网络LSA（Network LSA），类型： 2**\r\n\r\n  每一个多路访问网络中的指定路由器（DR）将会产生网络LSA通告，网络LSA只在产生这条网络LSA的区域内部进行泛洪扩散。网络LSA列出了所有与DR相连的路由器，包括DR自身。\r\n  \r\n- **网络汇总LSA（Network Summary LSA），类型： 3**\r\n\r\n  是由ABR路由器始发的。ABR路由器将发送网络汇总LSA到一个区域，用来通告该区域外部的目的地址。\r\n  \r\n  当其他路由器从一台ABR路由器收到一条网络汇总LSA时，它并不运行SPF算法。相反地，它只是把通告的目的地连同计算所得的代价一起记录至路由表，这其实是距离矢量协议的行为，也是为什么要求所有的域间通信量都必须通过骨干区域的原因——这些区域其实构成了一个星形拓扑，避免出现环路。\r\n  \r\n- **ASBR汇总LSA（ASBR Summary LSA），类型： 4**\r\n\r\n  也是由ABR路由器始发。ASBR汇总LSA除了所通告的目的地是一台ASBR路由器而不是一个网络外，其他的和网络汇总LSA都是一样的。\r\n\r\n- **自主系统外部LSA（Autonomous System External LSA），类型： 5**\r\n\r\n  或者称为**外部LSA（External LSA）**，是始发于ASBR路由器的，用来通告到达OSPF自主系统外部目的地或者OSPF自主系统外部的缺省路由的LSA。外部LSA通告将在整个自主系统中进行泛洪扩散。\r\n  \r\n- **NSSA外部LSA（NSSA External LSA），类型： 7**\r\n\r\n  是指在非纯末梢区域（Not-So-Stubby Area）内始发于ASBR路由器的LSA通告。NSSA外部LSA通告几乎和自主系统外部LSA通告是相同的，只是NSSA外部LSA通告仅仅在始发这个NSSA外部LSA通告的非纯末梢区域内部进行扩散。\r\n  \r\n#### 末梢（Stub）区域\r\n\r\n末梢区域是一个不允许AS外部LSA通告在其内部进行泛洪扩散的区域。如果在一个区域里没有学到类型5的LSA通告，那么类型4的LSA通告也是不必要的了。\r\n\r\n位于末梢区域边界的ABR路由器将使用网络汇总LSA向这个区域通告一个简单的缺省路由（目的地址是0.0.0.0）。在区域内部路由器上，所有和域内或域间路由不能匹配的目的地址都将最终匹配这条缺省路由。由于缺省路由是由类型3的LSA通告传送的，因此它不会被通告到这个区域的外部去。\r\n\r\n在末梢区域中有4个限制条件：\r\n\r\n- 所有末梢区域内的路由器都会在它们的Hello数据包中把E-bit设置为0。\r\n\r\n- 虚链路不能在一个末梢区域内进行配置，也不能穿过一个末梢区域。\r\n\r\n- 末梢区域内的路由器不能是ASBR路由器。\r\n\r\n- 一个末梢区域可以拥有多台ABR路由器，但是因为缺省路由的关系，区域内部路由器将不能确定哪一台路由器才是到达ASBR路由器的最优网关。\r\n\r\n1. **完全末梢区域**\r\n\r\n   由Cisco提出的，阻塞3,4,5类LSA，仅允许通告缺省路由的那一条3类LSA通过。\r\n  \r\n2. **非纯末梢区域**\r\n\r\n    非纯末梢区域（Not-So-Stubby-Area，NSSA）允许外部路由通告到OSPF自主系统内部，而同时保留自主系统其余部分的末梢区域特征。为了做到这一点，在NSSA区域内的ASBR将始发类型7的LSA用来通告那些外部的目的网络。这些NSSA外部LSA将在整个NSSA区域中进行泛洪扩散，但是会在ABR路由器的地方被阻塞。\r\n  \r\n    NSSA外部LSA在它的头部有一个称为P-bit的标志。NSSA ASBR路由器可以设置或清除这个P-bit，如果一台NSSA ABR路由器收到一条P-bi设置为1的7类LSA数据包，那么它将把这条7类LSA转换成为类型5的LSA，并且将这条LSA泛洪到其他区域中去。如果这个P-bit被设置为0,那么将不会转换这条7类LSA，而且这条7类LSA携带的目的地址也不能通告到这个NSSA区域的外部。\r\n  \r\n| 区域类型             | 1和2  | 3     | 4     | 5      | 7      |\r\n| :----------------- | :---: | :---: | :---: | :----: | :----: |\r\n| 骨干区域（区域 0）    | 允许   | 允许   | 允许  | 允许    | 不允许  |\r\n| 非骨干区域，非末梢区域 | 允许   | 允许   | 允许  | 允许    | 不允许  |\r\n| 末梢区域            | 允许   | 允许   | 不允许 | 不允许  | 不允许  |\r\n| 完全末梢区域         | 允许   | 不允许 | 不允许 | 不允许  | 不允许  |\r\n| NSSA               | 允许   | 允许 | 允许    | 不允许  | 允许    |\r\n   \r\n### 路由表\r\n\r\n#### 路径类型\r\n\r\n每一条到达一个网络目的地的路由都可以被归类到4种路径类型中的一种：\r\n\r\n- **区域内路径（Intra-area path）**    是指在路由器所在的区域内就可以到达目的地的路径。\r\n\r\n- **区域间路径（Inter-area path）**    是指目的地在其他区域但是还在OSPF自主系统内的路径。\r\n\r\n- **类型1的外部路径（Type 1 external path，E1）**    是指目的地在OSPF自主系统外部的路径。当一条外部路由重新分配到任何一个自主系统时，它都必须指定一个对就自主系统中的路由选择协议有意义的度量值。在OSPF协议里，ASBR路由器的责任是要给通告的外部路由指定一个代价值。对于类型1的外部路径来说，这个代价值是这条路由的外部代价加上到达ASBR路由器的路径代价之和。\r\n\r\n- **类型2的外部路径（Type 2 external path，E2）**    也是指目的地在OSPF自主系统外部的路径，但是在计算外部路由的度量时不再计入到达ASBR路由器的内部路径代价。\r\n   \r\n### OSPF数据包格式\r\n\r\n![OSPF数据包组成](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/OSPF%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%B0%81%E8%A3%85%E7%BB%84%E6%88%90.png \"OSPF数据包组成\")\r\n\r\n\r\n![OSPF包头](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/OSPF%E5%8C%85%E5%A4%B4.png \"OSPF包头\")\r\n\r\nOSPF数据包的IP包头TTL为1，OSPF数据包包头长度为24字节。\r\n\r\n- **版本（Version）**\r\n  \r\n  是指OSPF的版本号。OSPF的版本号是2，对于IPv6的OSPF版本号是3。\r\n  \r\n- **类型**\r\n\r\n  指出跟在头部后面的数据包类型\r\n  \r\n  |类型代码 | 描述        |\r\n  | ----- | -----      |\r\n  |1      | Hello      |\r\n  |2      | 数据库描述   |\r\n  |3      | 链路状态请求 |\r\n  |4      | 链路状态更新 |\r\n  |5      | 链路状态确认 |\r\n\r\n- **数据包长度（Packet Length）**\r\n\r\n  是指OSPF数据包的长度，包括数据包头部的长度，单位是字节。\r\n  \r\n- **路由器ID（Router ID）**\r\n\r\n  是指始发路由器的ID\r\n  \r\n- **区域ID（Area ID）**\r\n\r\n  始发数据包路由器所在的区域。如果数据包是在一个虚链路上发送的，那么区域ID就为0.0.0.0。\r\n  \r\n- **校验和（Checksum）**\r\n\r\n  一个对整个数据包（包括包头）的标准IP校验和\r\n  \r\n- **认证类型（AuType）**\r\n\r\n  是指正在使用的认证模式\r\n  \r\n  |认证类型代码（AuType）| 认证类型         |\r\n  | ----------------- | --------------- |\r\n  |0                  |空（没有认证）     |\r\n  |1                  |简单（明文）口令认证|\r\n  |2                  |加密校验和（MD5）  |\r\n  \r\n- **认证（Authentication）**\r\n\r\n  如果Autype=0，将不检查这个认证字段，因此可以是任何内容\r\n  \r\n  如果Autype=1，这个字段将包含一个最长为64位的口令。\r\n  \r\n  如果Autype=2，这个认证字段将包括一个密钥ID、认证数据长度和一个加密序列号。这个认证消息摘要附加在OSPF数据包的尾部，不作为OSPF数据包本身的一部分（不影响OSPF数据包的长度，但影响IP数据包的长度）\r\n  \r\n- **密钥ID（Key ID）**\r\n\r\n  标识认证算法和创建消息摘要使用的安全密钥\r\n  \r\n- **认证数据长度（Autentication Data Length）**\r\n\r\n  指明附加在OSPF数据包尾部的消息摘要的长度，单位是字节。\r\n  \r\n- **加密序列号（Cryptographic Sequence Number**\r\n\r\n  是一个不会减小的数字（达到最大值后再从0开始），用来防止重现攻击（Replay attacks）。\r\n  \r\n#### Hello数据包\r\n\r\n  ![OSPF协议 Hello数据包](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/OSPF%E7%9A%84Hello%E6%8A%A5%E6%96%87.png \"OSPF协议 Hello数据包\")\r\n  \r\n  Hello数据包是用来建立和维护邻接关系的。为了形成一种邻接关系，Hello数据包携带的参数必须和它的邻居保持一致。\r\n  \r\n- **网络掩码（Network Mask）**\r\n\r\n  是指发送数据包的接口的网络掩码。如果接收数据包的接口的网络掩码和这个掩码不匹配，那么该数据包会被接收方丢弃。\r\n  \r\n- **Hello时间间隔（Hello Interval）**\r\n\r\n  是指接口上发送Hello数据包的间隔时间，单位是秒。如果发送方和接收方的这个值不一致，那么它们无法建立邻居关系。一般是10s。\r\n  \r\n- **可选项（Option）**\r\n\r\n  这个字段可以用来确保邻居之间的兼容性问题。一台路由器可以拒绝一台兼容性不匹配的路由器。\r\n  \r\n- **路由器优先级（Router Priority）**\r\n\r\n  用来选举DR和BDR的。如果为0,那么始发路由器将没有资格选成DR和BDR。\r\n  \r\n- **路由器无效时间间隔（Router Dead Interval）**\r\n\r\n  是指始发路由器在宣告邻居路由器无效之前，将要等待从邻居路由器发出的Hello数据包的时长，单位是秒。如果路由器收到Hello数据包中的该值和接收接口配置的RouterDeadInterval不匹配，那么这个Hello数据包将被丢弃。一般是Hello间隔的4倍。\r\n  \r\n- **指定路由器（DR）**\r\n\r\n  是指网络上指定路由器的IP地址，注意，在DR选举过程中，这里只是始发路由器所认为的DR，不是最终选举出来的DR。只要Hello包能正常交互，所有路由器根据算法选出的DR/BDR必定一致。\r\n  \r\n- **备份指定路由器（BDR）**\r\n\r\n  是指网络上备份指定路由器的IP地址。同样的，在BDR选举过程中，这里只是始发路由器所认为的BDR，不是最终选举出来的BDR。\r\n  \r\n- **邻居（Neighbor）**\r\n\r\n  是一个递归字段，如果始发路由器在过去的一个RouterDeadInterval时间内，从网络上已经收到来自它的某些邻居的有效Hello数据包，那么将会在这个字段中列出所有这些邻居的RID。\r\n  \r\n#### 数据库描述数据包\r\n\r\n数据库描述数据包用于正在建立的邻接关系。数据库描述数据包的一个主要目的是描述始发路由器数据库中的一些或者全部LSA信息，这个操作只需列出LSA的头部就可以。数据库描述数据包中包含了一个主/从控制关系的标志，用来管理这些数据包的交换。\r\n\r\n![OSPF数据库描述数据包](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/OSPF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%8F%E8%BF%B0%E6%8A%A5%E6%96%87.png \"OSPF数据库描述数据包\")\r\n\r\n- **接口MTU（Interface MTU）**\r\n\r\n  是指数据包在不分段的情况下，始发路由器接口可以发送的最大IP数据包大小，单位是字节。当数据包在虚链路上传送时，这个字段是为0x0000。\r\n  \r\n  如果数据库描述包中的MTU值大于路由器接收端口的MTU值，这个数据库描述包会被丢弃（译注：RFC中用词是rejected）。\r\n  \r\n- **可选项（Option）**\r\n\r\n  路由器支持的一些可选能力。\r\n  \r\n- **I 位或称为初始位（Initial bit）**\r\n\r\n  当发送的是一系列数据库描述数据包中的最初一个数据包时，该位设置为1。后续的数据库描述数据包把该位设置为0。\r\n  \r\n- **M 位或称为后继位（More bit）**\r\n\r\n  当发送的数据包还不是一系列数据库描述数据包中的最后一个数据包时，将该位设置为1。最后的一个数据库描述数据包将把该位设置为0。\r\n  \r\n- **MS位， 或称为主/从位（Master/Slave bit）**\r\n\r\n  在数据库同步过程中，该位设置为1，用来指明始发数据库描述数据包的路由器是一台“主”路由器，“从”路由器将设置该位为0。\r\n  \r\n- **数据库描述序列号（DD Sequence Number）**\r\n\r\n  在数据库的同步过程中，用来确保路由器能够收到完整的数据库描述数据包序列。这个序列号将由“主”路由器在最初发送的数据库描述数据包中设置一些惟一的数值，而后续数据包的序列号将依次增加。\r\n  \r\n- **LSA头部（LSA Header）**\r\n\r\n  列出了始发路由器的链路状态数据库中部分或全部LSA头部。LSA头部里包含有足够的信息可以惟一地标识一个LSA和一个LSA的具体实例。\r\n  \r\n#### 链路状态请求数据包\r\n\r\n在数据库同步过程中如果收到了数据库描述数据包，路由器将会查看数据库描述数据包里有哪些LSA不在自己的数据库中，或者有哪些LSA比自己数据库中的LSA更新。然后将这些LSA记录在自己的链路状态请求列表中。接着，路由器会发送一个或多个链路状态请求数据包去向它的邻居请求发送在链路状态请求列表中的这些LSA副本。\r\n\r\n一个数据包可以根据一个LSA头部的类型、ID和通告路由器进行惟一的标识，但是它不能请求这个LSA的具体实例（LSA的具体实例由LSA头部的序列号、校验和以及老化时间标识）。它的请求都是期望得到LSA的最新实例。\r\n\r\n ![OSPF链路状态请求数据包](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/OSPF%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png \"OSPF链路状态请求数据包\")\r\n \r\n - **链路状态类型（Link State Type）**\r\n \r\n   指明LSA是一个路由器LSA、网络LSA还是其他类型的LSA。\r\n   \r\n - **链路状态ID（Link State ID）**\r\n \r\n   是LSA头部中的一个字段。\r\n   \r\n- **通告路由器（Advertising Router）**\r\n\r\n  是指始发LSA通告的路由器的路由器ID。\r\n  \r\n#### 链路状态更新数据包\r\n\r\n链路状态更新数据包是用于LSA的泛洪扩散和发送LSA去响应链路状态请求数据包的。OSPF数据包是不能离开发起它们的网络的（因为TTL=1）。因此，一个链路状态数据包可以携带一个或多个LSAA。接收LSA的邻居将负责在新的LS更新数据包中重新封装相关的LSA，从而进一步扩散到它自己的邻居。\r\n\r\n![OSPF链路状态更新数据包](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/OSPF%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%8C%85.png \"OSPF链路状态更新数据包\")\r\n\r\n- **LSA数量（Number of LSA）**\r\n\r\n  指出这个数据包中包含的LSA的数量。\r\n  \r\n- **链路状态通告（LSA）**\r\n\r\n  是指携带的完整的LSA（不只是LSA头部）。每一个更新数据包都可以携带多个LSA。\r\n  \r\n#### 链路状态确认数据包\r\n\r\n多个LSA可以通过单个链路状态确认数据包来确认。\r\n\r\n![OSPF链路状态确认数据包](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/OSPF%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E7%A1%AE%E8%AE%A4%E6%95%B0%E6%8D%AE%E5%8C%85.png \"OSPF链路状态确认数据包\")\r\n\r\n### OSPF的LSA格式和产生方法\r\n\r\n#### LSA的头部\r\n\r\n在LSA头部中有3个字段可以惟一地识别每个LSA：类型、链路状态ID和通告路由器。另外，还有其他3个字段可以惟一地识别一个LSA的最新实例：老化时间、序列号和校验和。\r\n\r\n![OSPF协议LSA头部](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/OSPF%E7%9A%84LSA%E6%8A%A5%E6%96%87%E5%A4%B4%E9%83%A8.png \"OSPF协议LSA头部\")\r\n\r\n- **老化时间（Age）**\r\n\r\n  是指从发出LSA后所经历的时间，单位是秒。当泛洪扩散LSA时，在从每一台路由器接口转发出去时，LSA的老化时间都会增加一个InfTransDelay的秒数。当然，当LSA驻留在链路状态数据库内时，这个老化时间也会增大。\r\n  \r\n  LSA的老化时间不会超过MaxAge（1小时）。老化时间达到MaxAge的LSA不会被用在路由表计算中，并会重新被泛洪。\r\n  \r\n- **可选项（Option）**\r\n\r\n  指出了在部分OSPF域中LSA能够支持的可选能力。\r\n  \r\n- **类型（Type）**\r\n\r\n  就是LSA的类型。\r\n  \r\n- **链路状态ID（Link State ID）**\r\n\r\n  用来指定LSA所描述的部分OSPF域（？）。这个字段根据不同的LSA类型取不同的值。\r\n  \r\n  |LS Type |Link State ID的值                                            |\r\n  | ------ | ---------------------------------------------------------- |\r\n  |1       |The originating router\'s Router ID                          |\r\n  |2       |The IP interface address of the network\'s Designated Router |\r\n  |3       |The destination network\'s IP address                        |\r\n  |4       |The Router ID of the described AS boundary router           |\r\n  |5       |The destination network\'s IP address                        |\r\n  \r\n  When an AS-external-LSA (LS Type = 5) is describing a default route, its Link State ID is set to DefaultDestination (0.0.0.0).\r\n  \r\n- **通告路由器（Advertising Router）**\r\n\r\n  是指始发LSA的路由器的ID。\r\n  \r\n- **序列号（Sequence Number）**\r\n\r\n  当LSA每次有新实例产生时，这个序列号就会增加。\r\n  \r\n- **校验和（Checksum）**\r\n\r\n  这是一个除了Age字段之外，关于LSA的全部信息的校验和。\r\n  \r\n- **长度（Length）**\r\n\r\n  是一个包含LSA头部在内的LSA长度，单位是字节。\r\n  \r\n#### 路由器LSA\r\n\r\n  路由器LSA是由每一台路由器产生的。它列出了一台路由器的链路或接口，同时也列出了这些接口的状态和每一条链路的出站代价。路由器LSA只能在始发区域泛洪。\r\n  \r\n  路由器所属某个区域的所有接口必须在单个LSA内描述。\r\n  \r\n  ![OSPF的路由器LSA](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/OSPF%E7%9A%84%E8%B7%AF%E7%94%B1%E5%99%A8LSA.png \"OSPF的路由器LSA\")\r\n  \r\n- **链路状态ID（Link State ID）**\r\n  \r\n  路由器LSA的链路状态ID是指始发路由器的路由器ID。\r\n  \r\n- **V，或虚链路端点位（Virtual Link Endpoint bit）**\r\n\r\n  为1时，说明始发路由器是一条或多条具有完全邻接关系的虚链路的一个端点，这里被描述的区域是传送区域。\r\n  \r\n- **E，或外部位（External bit）**\r\n\r\n  当始发路由器是一个ASBR路由器时，设置该位为1。\r\n  \r\n- **B，或边界位（Border bit）**\r\n\r\n  当始发路由器是一个ABR路由器时，该位为1。\r\n  \r\n- **链路数量（Number of Links）**\r\n\r\n  标明一个LSA所描述的路由器链路数量。\r\n\r\n下面的字段用来描述路由器的（区域内的）每条链路。\r\n\r\n每条链路都有**链路类型**字段，其他字段的值会根据**链路类型**的不同而变化。\r\n  \r\n- **链路类型（Link Type）**\r\n  \r\n  描述了链路所提供连接的一般类型。\r\n  \r\n  注意，路由器LSA把主机路由（host routes）归类为末梢网络来通告，且掩码是255.255.255.255。\r\n  \r\n  |链路类型 |连接                  |\r\n  | -----  | ------------------  |\r\n  |1       |点到点连接到另一台路由器 |\r\n  |2       |连接到一个传送网络      |\r\n  |3       |连接到一个末梢网络      |\r\n  |4       |虚链路                |\r\n  \r\n  传送网络是指一个网络中有两个或更多的路由器\r\n  \r\n- **链路ID（Link ID）**\r\n\r\n  这个字段的取值依赖于链路类型（Link Type）。用来标识链路连接的对象，This Link ID gives a name to the entity that is on the other end of the link.\r\n  \r\n  当连接的是一个也会产生LSA的对象时（如：路由器或传送网络），链路ID等于邻居LSA的链路状态ID（Link State ID）（不懂,P341）。\r\n  \r\n  |Link type |Description             |Link ID                                |\r\n  | -------- | ---------------------- | ------------------------------------- |\r\n  |1         |Point-to-point link     |Neighbor Router ID                     |\r\n  |2         |Link to transit network |Interface address of Designated Router |\r\n  |3         |Link to stub network    |IP network number                      |\r\n  |4         |Virtual link            |Neighbor Router ID                     |\r\n  \r\n- **链路数据（Link Data）**\r\n\r\n  这个字段的取值也是依赖于链路类型（Link Type）。\r\n  \r\n  当链路类型是**有编号的点到点链路**，**传送链路**，**虚链路**时，这个值取和网络相连的始发路由器接口的IP地址。有编号的点到点链路是指接口配有IP地址。\r\n  \r\n  当链路类型是**末梢网络**时，这个值取网络的IP地址掩码。\r\n  \r\n  当链路类型是**无编号的点到点链路**，这个值取接口的MIB-II ifIndex值。无编号的点到点链路是指接口没有地址，它是借用其他接口的地址。\r\n  \r\n- **TOS数量（Number of TOS）**\r\n\r\n  RFC2328已经不再支持，为了兼容性才做保留，如果没有多余的TOS度量，这个值为0。\r\n  \r\n- **TOS**，**TOS度量（TOS Metric）**\r\n\r\n  这两个字段是为了兼容以前的OSPF而保留。如果TOS数量（Number of TOS）为0，将没有这些字段。\r\n  \r\n##### 构造路由器LSA的过程\r\n\r\n假设路由器想要在Area A内构造一个路由器LSA，它会检测自己的每个接口数据结构，为每个接口执行以下步骤：\r\n\r\n1. 如果接口连接的网络不属于Area A，跳过这个接口，继续下一个接口。\r\n\r\n2. 如果接口的状态是Down，跳过这个接口。\r\n\r\n3. 如果接口的状态是Loopback，而且它没有连接到未编号点到点网络(也就是没有被未编号的点到点接口借用IP)，就在路由器LSA中添加一条类型3的链路，链路ID设置为接口的IP地址，链路数据设置为255.255.255.255，代价设置为0（思科设置为1）。\r\n\r\n4. 其他的接口会根据OSPF接口的类型在LSA中添加不同的链路描述。\r\n\r\n###### 描述点到点接口\r\n\r\n对于点到点接口：\r\n\r\n- 如果邻居路由器是全邻接（Full）状态，添加一条类型1（Poin-To-Point）链路。链路ID设置为邻居路由器的路由器ID。如果是有编号的点到点网络，链路数据设为接口IP地址。如果是未编号点到点网络，链路数据设为接口的MIB-II ifIndex值。代价设置为接口的出站代价。\r\n\r\n- 另外，只要接口的状态是“Point-to-Point”（不管邻居路由器是什么状态），一条类型3（stub network）的链路应该被添加到LSA。有两种格式可以选择：\r\n\r\n  - Option 1\r\n    \r\n    假设邻居路由器的IP地址已知（？），设置链路ID为邻居的IP地址，链路数据为255.255.255.255，代价为接口的出站代价。\r\n    \r\n  - Option 2\r\n    \r\n    如果一个子网分配到点到点链路，设置链路ID为子网的网络地址，链路数据为子网掩码，代价为接口出站代价。\r\n    \r\n###### 描述广播和NBMA接口\r\n\r\n对于可操作的广播和NBMA接口，按照下面的步骤添加一条链路到网络LSA中：\r\n\r\n如果接口的状态是Wating，添加一条类型3（stub network）的链路，链路ID设置为它连接的网络的网络号，链路数据设置为网络的网络地址掩码，代价为接口的出站代价。\r\n\r\n否则，说明此时网络中已经选举出一台DR。\r\n\r\n- 如果路由器和DR是全邻接或者它自身就是DR且至少有一台其他的路由器和它是全邻接，添加一条类型2（transit network）的链路，链路ID设置为网络中DR的接口IP地址（可能路由器自身就是DR），链路数据设置为路由器自己接口的IP地址，代价是接口的出站代价。\r\n\r\n- 如果是其他的，按照接口状态是Wating处理。\r\n  \r\n###### 主机路由（Host Route）的定义\r\n\r\n路由器LSA把主机路由（host routes）归类为末梢网络来通告，且掩码是255.255.255.255。\r\n\r\n它们可以是路由器连接到点到点网络的接口、路由器的环回接口或直接连接到路由器的IP主机。\r\n  \r\n#### 网络LSA\r\n\r\n网络LSA是指始发于指定路由器（DR）的。这些网络LSA将通告一个多路访问网络与这个网络相连的所有路由器（包括DR）。像路由器LSA一样，网络LSA也只能在始发这条网络LSA的区域内进行泛洪扩散。\r\n\r\n![OSPF的网络LSA](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/OSPF%E7%9A%84%E7%BD%91%E7%BB%9CLSA.png \"OSPF的网络LSA\")\r\n\r\n- **链路状态ID（Link State ID**\r\n\r\n  是指网络中DR路由器接口上的IP地址。\r\n  \r\n- **网络掩码（Network Mask）**\r\n\r\n  指定这个网络上使用的地址或子网的掩码。\r\n  \r\n- **相连的路由器（Attached Router）**\r\n\r\n  列出了多路访问网络上所有与DR形成完全邻接关系的路由器的路由器ID，以及DR路由器本身的路由器ID。\r\n  \r\n#### 汇总LSA－网络汇总LSA和ASBR汇总LSA\r\n\r\n网络汇总LSA（类型3）和ASBR汇总LSA（类型4）具有同样的格式，惟一不同之处是它们的类型和链路状态ID。ABR路由器将产生这两种类型的汇总LSA。\r\n\r\n网络汇总LSA通告的是一个区域外部的网络（包括缺省路由），而ASBR汇总LSA通告的是一个区域外部的ASBR路由器。这两种类型的LSA都只能泛洪扩散到单个区域。\r\n\r\n![OSPF的汇总LSA](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/OSPF%E7%9A%84%E6%B1%87%E6%80%BBLSA.png \"OSPF的汇总LSA\")\r\n\r\n##### 网络汇总LSA\r\n\r\n当一台ABR始发一条网络汇总LSA时，将包括从它本身到正在通告的这条LSA的目的地所耗费的代价。ABR路由器即使知道它有多条路由可以到达目的地，它也只会为这个目的地始发单条网络汇总LSA通告。因此，如果一台ABR路由器在它本身相连的区域内有多条路由可以到达目的地，那么它将只会始发单一的一条网络汇总LSA到骨干区域，而且这条网络汇总LSA是上述多条路由中代价最低的。\r\n\r\n- **链路状态ID（Link State ID）**\r\n\r\n  对于类型3的LSA来说，它是所通告的网络或子网的IP地址。\r\n  \r\n  对于类型4的LSA来说，它是所通告的ASBR路由器的路由器ID。\r\n  \r\n- **网络掩码（Network Mask）**\r\n\r\n  在类型3的LSA中，是指所通告的网络的子网掩码或地址。\r\n  \r\n  在类型4的LSA中，这个字段没有实际意义，并被设置为0.0.0.0。\r\n  \r\n- **度量（Metric）**\r\n\r\n  是指路由器到达目的地的路由代价。通常是到目的地路由的代价（直连的代价为0）、与目的地相连接口的代价之和。\r\n  \r\n##### 构造汇总LSA的过程\r\n\r\n汇总LSA描述的目的地址为一个IP网络、一个AS边界路由器或一段IP地址。汇总LSA只能在单一区域内泛洪。被描述的目的地址位于区域外部但仍然属于自治系统。\r\n\r\n汇总LSA由区域边界路由器（ABR)产生。通过下面的算法检查路由表数据结构，使精确的汇总路由通告给某个区域。注意，只有域内路由（intra-area routes）会被通告到骨干区域；域内路由和域间路由（inter-area routes）都会被通告到其他区域。\r\n\r\n例如，为了决定哪些路由被通告到邻接的区域A，对每个路由条目进行以下处理（请记住，每个路由表条目都描述了一组\r\n通往特定目的地的等价最佳路径）：\r\n\r\n- 只有目的类型为一个网络或AS边界路由器（ASBR）的，才会由汇总LAS通告。如果路由条目的目的类型是区域边界路由器，检查下一个路由条目。\r\n\r\n- AS外部路由决不会由汇总LSA通告。如果路由条目的路径类型（Path-type）有type 1 external或type 2external中的任意一个，检查下一个路由条目。\r\n\r\n- 此外，如果与这组路径关联的区域是区域A本身，则不要为路径生成汇总LSA。\r\n\r\n- 此外，如果与这组路径关联的下一跳属于区域A本身，则不要为路径生成汇总LSA。这是水平分隔的逻辑。\r\n\r\n- 此外，如果路由目的是一个ASBR，仅且路由条目是去往这个ASBR的最优路径时会产生一个类型4的汇总LSA。链路状态ID是ASBR的路由器ID，代价为路由表中代价。注意：如果区域A被配置为一个stub区域，则不会产生这些LSA。\r\n\r\n- 此外，如果目的类型是网络。又如果这是一条域间（inter-area）路由，则产生一个类型3的汇总LSA，链路状态ID是网络的地址（如果有必要，网络状态ID可以有一位或多位主机位置位），代价为路由表中的代价。\r\n\r\n- 最后一种情况是去往一个网络的域内（intra-area）路由。这意味着这个网络处于与路由器直接相连的区域内。通常，这些信息在汇总LSA里出现之前必须被压缩。请记住，某个区域具有已配置的地址范围列表，每个范围包含[地址，掩码]，以及Advertise或DoNotAdvertise的状态指示。每个范围最多只产生一个Type 3汇总LSA。当范围的状态指示Advertise时，将生成Type 3汇总LSA，其Link State ID等于范围的地址（主机位可根据需要置位），并且代价等于组件网络中最大的那个。当范围的状态指示DoNotAdvertise时，Type 3汇总LSA会被抑制，并且组件网络对其他区域隐藏。\r\n\r\n  (...省略...)\r\n  \r\n  In other words, the backbone’s configured ranges should be ignored when originating summary-LSAs into transit areas.\r\n\r\n  TODO\r\n  \r\n#### 自主系统外部LSA\r\n\r\n自主系统外部LSA是由ASBR路由器始发的。这些自主系统外部LSA是用来通告OSPF自主系统外部的目的网络的，这里也包括到达外部目的网络的缺省路由。\r\n\r\n自主系统外部LSA可以泛洪到OSPF域中所有非末梢区域中去。\r\n\r\n![OSPF的自主系统外部LSA](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/OSPF%E7%9A%84%E8%87%AA%E4%B8%BB%E7%B3%BB%E7%BB%9F%E5%A4%96%E9%83%A8LSA.png \"OSPF的自主系统外部LSA\")\r\n\r\n- **链路状态ID**\r\n\r\n  自主系统外部LSA的链路状态ID是指目的地的IP地址。\r\n  \r\n- **网络掩码**\r\n\r\n  是指所通告的目的地的子网掩码。\r\n  \r\n如果类型5的LSA正在通告的是一条缺省路由，那么链路状态ID和网络掩码字段都将被设置为0.0.0.0。\r\n  \r\n- **E，或称为外部度量位（External Metric bit）**\r\n\r\n  用来指定这条路由使用的外部度量的类型。如果E-bit为0，那么度量类型就是E1；如果E-bit为1，那么度量类型就是E2。（E1，E2参考330页后再补充）\r\n  \r\n- **度量**\r\n\r\n  是指路由的代价，由ASBR路由器设定。\r\n  \r\n- **转发地址（Forwarding Address）**\r\n\r\n  是指到达所通告的目的地的数据包应该被转发到的地址。如果转发地址是0.0.0.0，那么数据包将被转发到始发ASBR上。\r\n  \r\n- **外部路由标志（External Route Tag）**\r\n\r\n  是一个应用于外部路由的任意标志。OSPF协议本身并不使用这个字段，而是由外部路由来管理和控制。\r\n  \r\n可选地，TOS字段也可以和某个目的地关联。这些字段和前面讲述的是相同的，只是每一个TOS度量也都有自己的E-bit、转发地址和外部路由标志。\r\n\r\n##### 构造自治系统外部LSA（AS-external-LSAs）\r\n\r\nAS外部LSA描述到自治系统外部目的地的路由。大部分AS外部LSA描述的都是到特定外部目的地的路由，这时LSA的链路状态ID为目的网络的IP地址。然而，AS外部LSA也可能会为自治系统生成一条默认路由，这时LSA的状态ID为默认地址（0.0.0.0）。\r\n\r\nAS外部LSA由AS边界路由器（ASBR）生成。ASBR为从其它路由协议学到的每条外部路由生成一个AS外部LSA。\r\n\r\nAS外部LSA是惟一一种在整个自治系统泛洪的LSA类型，其他类型的LSA只会在单一区域内泛洪。但是，AS外部LSA不会被泛洪到或穿过末梢区域。\r\n\r\n被通告的外部路由的代价有两种，类型为1的代价与链路状态代价相同；类型为2的代价被认为比任何AS内部路径的代价都大。\r\n\r\n如果由AS外部LSA通告的路由变为了不可达，必须把LSA的age设置为MaxAge并在路由域内泛洪。\r\n\r\n#### NSSA外部LSA\r\n\r\nNSSA外部LSA是由一个NSSA区域内的ASBR路由器始发的。除了转发地址外，NSSA外部LSA的所有字段都和AS外部LSA的字段相同。\r\n\r\nNSSA外部LSA仅仅在始发它们的一个非纯末梢区域内进行泛洪。\r\n\r\n![OSPF的NSSA外部LSA](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/OSPF%E7%9A%84NSSA%E5%A4%96%E9%83%A8LSA.png \"OSPF的NSSA外部LSA\")\r\n\r\n- **转发地址**\r\n\r\n  如果网络在一台NSSA ASBR路由器和邻接的自主系统之间是作为一条内部路由通告的，那么这个转发地址就是指这个网络的下一跳地址。如果网络不是作为一条内部路由通告，那么这个转发地址将是NSSA ASBR路由器的路由器ID。\r\n  \r\n### 可选项字段\r\n\r\n可选字段是出现在每一个Hello数据包、数据库描述数据包和每一个LSA中的。可选字段允许路由器和其他路由器进行一些可选性能的通信。\r\n\r\n![OSPF的可选项字段](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/OSPF%E7%9A%84%E5%8F%AF%E9%80%89%E9%A1%B9%E5%AD%97%E6%AE%B5.png \"OSPF的可选项字段\")\r\n\r\n- **DN**    用于基于MPLS的第3层虚拟专用网（VPN）。\r\n\r\n- **O**    设置用来表明始发路由器支持Opaque LSA（类型9,类型10,类型11）\r\n\r\n- **DC位**    当始发路由器具有支持按需电路上的OSPF的能力时，该位被设置为1。\r\n\r\n- **EA位**    当始发路由器具有接收和转发外部属性LSA的能力（//TODO：需要详细解释）时，该位将被设置为1。\r\n\r\n- **N位**    只用在Hello数据包中。一台路由器设置N-bit=1表明它支持NSSA外部LSA。如果N-bit=0,那么路由器将不接受和发送NSSA外部LSA。如果N-bit=1，那么E-bit必须设置为0。\r\n\r\n- **P位**    只用在NSSA外部LSA的头部（由于这种情况，N-bit和P-bit可以使用在同一位置）（TODO:嘛意思）。该位将告诉一个非纯末梢区域中的ABR路由器将类型7的LSA转换为类型5的LSA。\r\n\r\n- **MC位**    当始发路由器具有转发IP组播数据包的能力时，该位将被设置。\r\n\r\n- **E位**    当始发路由器具有接受AS外部LSA的能力时，该位将被设置。在所有的AS外部LSA和所有始发于骨干区域以及非末梢区域的LSA中，该位将设置为1.而在所有始发于末梢区域的LSA中当，该位设置为0.另外，可以在Hello数据包中使用该位来表明一个接口具有接收和发送类型5的LSA的能力。E-bit不匹配的路由器将不能形成邻接关系，这个限制可以确保一个区域的所有路由器都同样地具有支持末梢区域的能力。\r\n\r\n- **MT位**    设置了该位表示始发路由器支持多拓扑OSPF（MT-OSPF）。\r\n\r\n[default-information originate](https://blog.csdn.net/weixin_33995481/article/details/91631654)\r\n\r\n[default-information originate](https://blog.51cto.com/lcbingo/578728)',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,87),(34,'Shell脚本01－用在小米路由器上的wol脚本','34',1551456000,1583037328,'<!--markdown-->\r\n这个脚本通过wol启动内网的主机，每次运行都会把路由器上的MAC地址表更新到mac_list文件，如果MAC地址已经存在则跳过这个MAC。\r\n\r\nmac_list中每行是一个MAC，MAC后可用逗号隔开，添加一个注释，如`4c:72:b9:e3:18:a1,Hasee_Laptop`，也可不添加注释。\r\n\r\n```\r\n#!/bin/sh\r\nmacs_file=\"/data/mac_list\"\r\n\r\nif [ -e $macs_file ]\r\nthen\r\n    #echo \"OK, find $macs_file\"\r\n    break\r\nelse\r\n    #echo \"Not find $macs_file, will create it\"\r\n    touch $macs_file\r\nfi\r\n\r\nmacs=`cat $macs_file`\r\n\r\n\r\n＃这个函数用来检查一个MAC是否已经存在mac_list文件中\r\nfindx(){\r\n    c=0\r\n    for mac in $macs\r\n    do\r\n        if [ $1 = ${mac::17} ]\r\n        then\r\n            let c++\r\n        fi\r\n    done\r\n\r\n    return $c\r\n}\r\n\r\n＃遍历路由器的MAC表项，如果是新的MAC就添加到mac_list文件\r\nfor arp in `cat /proc/net/arp |grep br-lan | awk \'{print $4}\'`\r\ndo\r\n    findx $arp\r\n    if [ $? -eq 0 ]\r\n    then\r\n        echo $arp >> $macs_file\r\n    fi\r\ndone\r\n\r\ni=0\r\nfor mac in $macs\r\ndo\r\n    let i++\r\n    echo \"$i.  $mac\"\r\ndone\r\n\r\nread -p \"Select: \" ch\r\nif [ $ch -gt $i ]\r\nthen\r\n    echo \"Bad select!\"\r\nelse\r\n    target=`head -n $ch $macs_file | tail -1 | awk -F \',\' \'{print $1}\'`\r\nfi\r\n\r\n＃如果用255.255.255.255作为目的地，路由器可能不会发送数据包，所以最好用接口的广播地址\r\nbcast_addr=`ifconfig br-lan |grep Bcast: |awk \'{print $3}\' |awk -F \':\' \'{print $2}\'`\r\n/data/usr/bin/wol $target -h $bcast_addr\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,95),(35,'思科cisco的命令手册','35',1552147200,1587222909,'<!--markdown-->查看端口聚合信息\r\n\r\n```\r\nSwitch#show etherchannel summary\r\nSwitch#show etherchannel load-balance   //查看负载信息\r\nSwitch#show etherchannel port-channel   //查看port-channel详细信息\r\nSwitch#show int trunk     查所有允许trunk 通道的VLAN\r\nSwitch#show int port-channel 1 trunk    查po1 允许通过的vlan  ，trunk 通道\r\n#show standby ?\r\n```\r\n\r\n# 生成树命令\r\n\r\n- `#show spanning-tree vlan 10`\r\n\r\n    查看vlan10的生成树实例\r\n\r\n- `(config)#spanning-tree mode {mst|pvst|rapid-pvst}`\r\n  \r\n    修改生成树的模式\r\n\r\n- `(config)#spanning-tree vlan {vlan-id} priority {0-61440}`\r\n  \r\n    修改pvst生成树的优先级，数字越小优先级越高。\r\n\r\n\r\n# 思科IOS的快捷键\r\n\r\n`exit`：退回到上一级模式\r\n\r\n`end`：可以在高于特权模式的模式下，直接退回到特权模式。\r\n\r\n`Ctrl+A`：移动光标到行首\r\n\r\n`Ctrl+E`：移动光标到行尾\r\n\r\n`Ctrl+U`：清除整行内容\r\n\r\n`Ctrl+Shift+6`：终止IOS的进程，如ping或traceroute\r\n\r\n`Ctrl+C`：取消当前的命令并回到特权模式\r\n\r\n`Ctrl+Z`：执行当前命令并回到特权模式\r\n\r\n输入问号：ctrl+v，然后就可以输入问号了',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,89),(36,'OSPFv2 RFC2328','36',1554480000,1583037486,'<!--markdown-->\r\n### 2.1.1 Representation of non-broadcast networks\r\n\r\nOSPF在非广播网络上有两种运行模式：`NBMA` 或 `Point-to-MultiPoint`。这两种方式用不同的方法处理Hello协议和泛洪。\r\n\r\n在NBMA模式下， OSPF模仿在广播网络下的操作方法：选举一台DR\r\n\r\n在Point-to-MultiPoint模式下，OSPF把router-to-router的连接作为point-to-point链路。不会选举DR，也不会产生网络LSA。\r\n\r\n（...不完整）\r\n\r\n## 10.5 Receiving Hello Packets\r\n\r\n本章节描述了对接收到的Hello报文的详细处理过程。\r\n\r\n通常来说，首先对接收到的OSPF报文进行IP头部、OSPF头部校验，接下来，把Hello报文中的**网络掩码**、**Hello间隔**和**RouterDead Internal的值**与接收端口上配置的值对比，任何一项不匹配都会中止处理进程并把报文丢弃。换句话说，以上值域是对邻接网络配置的准确描述，然而有个例外：在点到点和虚链路上，接收的Hello报文中的网络掩码应该被忽略。\r\n\r\n接收端口只能连接到一个OSPF区域（可以是主干区域），Hello报文中的**E-bit**设置必须与区域的ExternalRoutingCapability相匹配。如果AS-External-LSAs不泛洪到或穿过区域（比如stub区域），接收到的Hello报文中，E-bit必须清零，否则，E-bit必须置1。该项不匹配时报文会被丢弃，Hello报文中Option域的其他设备项应该被忽略。\r\n\r\n接下来，会尝试把Hello报文的源与接收端口的邻居做匹配。如果接收端口连接到广播网络、点到多点网络或NBMA网络，Hello报文的IP报头中的IP源地址就是源；如果接收端口连接到点对点链路或虚链路，Hello报文的OSPF报头中的路由器ID就是源。接口的当前邻居列表包含在接口的数据结构中。如果不能在邻居中找到匹配项（如，第一次发现邻居）。则创建一个邻居，这个邻居初始状态设置为Down。\r\n\r\n当在广播网络、点到多点网络或NBMA网络接收到邻居的Hello报文时，设置邻居数据结构中的邻居ID等于报文的OSPF报头中的路由器ID。对于这些网络类型，邻居数据结构中的路由器优先级、邻居的DR值和邻居的BDR值设置为所接收到的Hello报文中的对应值；应注意这些字段中的更改，以便在下面的步骤中使用。当在点到点网络（不是虚链路）收到Hello报文，设置邻居数据结构的邻居IP地址为报文的IP源地址。\r\n\r\n现在,将检查hello报文的其余部分,生成要提供给邻居和接口状态机的事件。这些状态机被指定执行或调度(参考4.4)。例如，通过执行下面指定的状态机，单个接收到的hello可能会影响几个邻居状态转换。\r\n\r\n- 每个Hello报文都会导致邻居状态机以HelloReceived事件执行。\r\n\r\n- 然后检查hello包中包含的邻居列表。如果路由器自身出现在列表中，应在收到事件 2-WayReceived的情况下执行邻居状态机。否则，应在收到事件 1-WayReceived的情况下执行邻居状态机，并且停止处理报文。\r\n\r\n- 接下来，如果注意到邻居的路由器优先级字段中有更改，那么接收端口的接口状态机将计划以事件NeighborChange执行。\r\n\r\n- 如果邻居路由器声明它自己是DR（Hello报文中DR字段的值等于邻居的IP地址）且报文中BDR的值为0.0.0.0，并且接收端口在Waiting状态，接收端口的接口状态机将执行BackupSenn事件。否则，如果邻居声明自己是DR，而它(指邻居)以前没有，或者邻居没有声明自己是DR，而它以前有，那么接收接口的状态机将计划以事件NeighborChange执行。\r\n\r\n- 如果邻居路由器声明它自己是BDR（Hello报文中BDR字段的值等于邻居的IP地址）并且接收端口在Waiting状态，接收端口的接口状态机将执行BackupSenn事件。否则，如果邻居声明自己是BDR，而它(指邻居)以前没有，或者邻居没有声明自己是BDR，而它以前有，那么接收接口的状态机将计划以事件NeighborChange执行。\r\n\r\n在NBMA网络上，收到Hello数据包也可能导致发送回一个Hello数据包用来响应，详细内容参考9.5.1。\r\n\r\n## 10.6 Receiving Database Description Packets\r\n\r\n本章节对接收到数据库描述报文的详细处理过程进行说明。\r\n\r\n入栈的数据库描述报文已经通过输入报文处理（Section 8.2），并与一个邻居和接收端口相关联。是否应该接收数据库描述报文或者已经接收了数据库描述报文接下来应该对它做什么处理，取决于邻居的状态。\r\n\r\n如果接收了一个数据库描述报文，报文中的以下字段应该保存到对应的邻居数据结构的“last received Database Description Packet“下：initialize（I），More（M）和master（MS）位，选项字段，还有数据库描述序列号（DD Sequence Number）。如果从邻居接收到的两个连续的数据库描述报文中，这些字段完全一致，对于下面的处理方式来说，第二个报文被视为是重复的。\r\n\r\n如果数据库描述报文中Interface MTU表明一个IP报文的尺寸大于路由器接收端口不分片的尺寸(MTU)，这个数据库描述报文会被拒绝（rejected）。否则，取决于邻居的状态，有以下行为：\r\n\r\n- **Down**：这个报文应该被拒绝。\r\n\r\n- **Attempt**：这个报文应该被拒绝。\r\n\r\n- **Init**：邻居状态机应该执行 2-way Received 事件。这会导致邻居的状态立即转换到 2-way 或 Exstart。如果新状态是Exstart，这个报文会继续按照下面Exstart状态的方式处理。\r\n\r\n- **2-Way**：这个报文应该被忽略，数据库描述报文只为用来建立邻接关系[7]\r\n\r\n- **ExStart**：如果接收到的报文满足以下条件，邻居状态应该执行Negotiation Done事件（状态会转到Exchange），报文的Option字段会记录到邻居数据结构的Neighbor Options字段，并且这个报文会加入到处理队列中。否则，报文被丢弃。\r\n\r\n  1. initialize（I），More（M）和master（MS）位被置1，报文的负载为空。并且邻居的路由器ID比自己的路由器ID大，这种情况下，路由器自己为Slave，设置master/slabe位为slave，设置邻居数据结构的DD序列号为master指定的值。\r\n  \r\n  2. initialize（I）和master（MS）位为零，报文中的DD序列号等于邻居数据结构的DD（这表示确认），并且邻居的路由器ID比自己的ID小，这种情况，路由器自身是master。\r\n  \r\n- **Exchange**：这个阶段下，master收到重复的DD报文会直接丢弃，slave收到重复的DD报文会把自己最后发送的DD报文重新发送一次。否则（DD报文不是重复的）:\r\n\r\n  1. 如果MS位的状态与master/slave协商时的状态不一致，产生邻居事件SeqnumberMismatch并停止处理这个报文。\r\n  \r\n  2. 如果initialize（I）位置1，产生邻居事件邻居事件SeqNumberMismatch并停止处理这个报文。\r\n  \r\n  3. 如果报文的Options字段与之前从邻居接收到不同（记录在邻居数据结构的Neighbor Options字段中），产生邻居事件SeqNumberMismatch，并停止处理报文。\r\n  \r\n  4. 数据描述报文必须按照报文中的DD序列号顺序处理。如果路由器是master，则下一个收到的报文中DD序列号应该等于邻居数据结构中的DD序列号。如果路由器是slave，则下一个收到的报文中DD序列号应该比邻居数据结构中的DD序列号大1.无论哪种情况，如果这个报文是队列中的下一个，它应该被接受并按照下面步骤处理报文中的内容。\r\n  \r\n  5. 否则，产生邻居事件SeqNumberMismatch并停止处理报文。\r\n  \r\n- **Loading or Full**：\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,65),(37,'crontab定时任务','37',1557504000,1583037526,'<!--markdown-->\r\n**cron引用的脚本中，建议使用绝对路径执行命令，不然可能会找不到命令。**\r\n\r\n使用`crontab -l`查看用户的定时任务\r\n\r\n使用`crontab -e`编辑用户的定时任务\r\n\r\n用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：\r\n\r\n![crontab](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/crontab-2.png \"crontab的格式\")\r\n\r\n\r\n修改crontab文件后，不会立即生效，需要过段时间(2分钟内)才会重新加载文件，日志内可以看到EDIT和RELOAD的时间\r\n\r\ncron的日志路径：`/var/log/cron`\r\n\r\n**查看关于cron的日志**\r\njournalctl  -u cron\r\n\r\n表示时间的特殊值：\r\n\r\n- `@reboot`：表示在机器重启后执行 \r\n\r\n在任务前加`#`符号表示注释。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,88),(38,'git的使用方法','38',1557590400,1588682520,'<!--markdown-->`git checkout bugfix`：切换到分支bugfix\r\n\r\n`git branch bugfix`：创建分支bugfix\r\n\r\n`git branch --list`：列出所有分支\r\n\r\n`git branch -vv`：列出分支详细信息\r\n\r\n把当前分支与远程分支建立映射关系：\r\n```\r\ngit branch -u origin/branch-a\r\n或\r\ngit branch --set-upstream-to origin/addFile\r\n```\r\n\r\n`git branch --unset-upstream`：撤销本地分支与远程分支的映射关系\r\n\r\n`git branch -D bugfix`：删除分支bugfix\r\n\r\n### 修改 git log 输出内容中的时区\r\n```bash\r\n//默认git的日志时区是 UTC +0000\r\n//中国的时区是 UTC +8000\r\n    \r\ngit log --date=local //临时生效\r\n//或者\r\ngit config --global log.date local //全局生效\r\n//查看\r\ngit config --list\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,91),(39,'在TinyCore中启用console口','39',1560614400,1583038185,'<!--markdown-->**tinycore的版本为10.1，文中的路径可能有误**\r\n\r\n1. 编辑extlinux.conf文件，路径: `/mnt/sda1/tce/boot/extlinux/extlinux.conf`\r\n    ```\r\n        serial 0 115200\r\n        display boot.msg\r\n        default microcore\r\n        label microcore\r\n                kernel /boot/vmlinuz\r\n                initrd /boot/core.gz\r\n                append loglevel=3 console=ttyS0,115200 console=tty0\r\n    ```\r\n2. 解压core.gz，路径：`/mnt/sda1/tce/boot/core.gz`\r\n    ```\r\n        mkdir file_system\r\n        cd file_system\r\n        zcat ../boot/tinycore.gz | sudo cpio -i -H newc -d\r\n    ```\r\n3. 修改inittab文件，路径：`file_system/etc/inittab`\r\n    ```\r\n        # /etc/inittab: init configuration for busybox init.\r\n        # Boot-time system configuration/initialization script.\r\n        #\r\n        ::sysinit:/etc/init.d/rcS\r\n        \r\n        # /sbin/getty respawn shell invocations for selected ttys.\r\n        tty1::respawn:/sbin/getty -nl /sbin/autologin 38400 tty1\r\n        #tty2::respawn:/sbin/getty 38400 tty2\r\n        #tty3::respawn:/sbin/getty 38400 tty3\r\n        #tty4::askfirst:/sbin/getty 38400 tty4\r\n        #tty5::askfirst:/sbin/getty 38400 tty5\r\n        #tty6::askfirst:/sbin/getty 38400 tty6\r\n        \r\n        ttyS0::respawn:/sbin/getty 38400 ttyS0 xterm\r\n        \r\n        # Stuff to do when restarting the init\r\n        # process, or before rebooting.\r\n        ::restart:/etc/init.d/rc.shutdown\r\n        ::restart:/sbin/init\r\n        ::ctrlaltdel:/sbin/reboot\r\n        ::shutdown:/etc/init.d/rc.shutdown\r\n    ```\r\n4. 修改securetty文件，路径：`file_system/etc/securetty`\r\n    ```\r\n        # /etc/securetty: List of terminals on which root is allowed to login.\r\n        #\r\n        console\r\n        \r\n        # For people with serial port consoles\r\n        ttyS0\r\n        \r\n        # Standard consoles\r\n        tty1\r\n        tty2\r\n        tty3\r\n        tty4\r\n        tty5\r\n        tty6\r\n        tty7\r\n    ```\r\n5. 修改issue文件（可选），路径：`file_system/etc/issue`，这个文件中的内容会在等待输入用户名时出现\r\n    ```\r\n        Core Linux\r\n        \r\n        username \'gns3\', password \'gns3\'\r\n        Run filetool.sh -b if you want to save your changes\r\n    ```\r\n6. 重新压缩并替换core.gz\r\n    ```\r\n        cd file_system\r\n        find | sudo cpio -o -H newc | gzip -2 > ../boot/tinycore.gz\r\n    ```\r\n参考:\r\n    \r\n[Serial Port console with syslinux question? ](http://forum.tinycorelinux.net/index.php/topic,11088.msg58088.html#msg58088)\r\n\r\n[Login at /dev/ttyS0](http://forum.tinycorelinux.net/index.php/topic,11088.msg58088.html#msg58088)\r\n\r\n[Need a Root Password to Change Files](http://forum.tinycorelinux.net/index.php?topic=9204.0)',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,102),(40,'在Debian上安装shadowsocks服务器','40',1565020800,1583038315,'<!--markdown--># 安装shadowsocks-libv\r\n略\r\n# 把shadowsocks添加为systemd服务\r\n1. 编辑`/etc/systemd/system/shadowsocks.service`文件\r\n\r\n    ```\r\n[Unit]\r\nDescription=Shadowsocks server\r\nAfter=network.target\r\n\r\n[Service]\r\nTimeoutStartSec=120\r\nExecStart=/usr/local/bin/ss-server -c /etc/shadowsocks.json\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n    ```\r\n\r\n# 编辑shadowsocks的配置\r\n1. 假设配置文件的路径为`/etc/shadowsocks.json`\r\n\r\n    ```\r\n{\r\n  \"server\": \"0.0.0.0\",\r\n  \"server_port\": 8388,\r\n  \"password\": \"PASSWORD\",\r\n  \"method\": \"chacha20-ietf-poly1305\"\r\n}\r\n    ```\r\n\r\n# 启用shadowsocks服务\r\n\r\n```\r\nsystemctl enable shadowsockes\r\nsystemctl start shadowsocks\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,83),(41,'Shell脚本-如果没有网络通信就关机','41',1565020800,1583038735,'<!--markdown-->**因为cron不会读取系统中PATH环境变量，所以cron引用的脚本中，建议使用绝对路径执行命令，不然可能会找不到命令。**\r\n\r\n使用shell脚本配合crontab，每30分钟一次检查GNS3服务是否与外部有通信，如果有通信则退出，如果没有通信则关机。\r\n\r\n1. 编写脚本/etc/gns3r.sh\r\n\r\n        ```\r\n        #如果GNS3服务没有与外部通信，就关闭主机。\r\n        if /usr/bin/uptime -p | grep hour\r\n        then\r\n                UPTIME=$(expr $(/usr/bin/uptime -p | awk \'{print $2}\') \\* 60 + $(uptime -p | awk \'{print $(NF-1)}\'))\r\n        else\r\n                UPTIME=$(/usr/bin/uptime -p | awk \'{print $(NF-1)}\')\r\n        fi\r\n\r\n        echo \"--------------------\" >> /home/gns3/uptime\r\n        echo $UPTIME >> /home/gns3/uptime\r\n\r\n        if [ $UPTIME -ge 20 ]\r\n        then\r\n                echo \"grater than 20 minutes\" >> /home/gns3/uptime\r\n                LOCAL_IP=$(/usr/sbin/ifconfig | grep \'inet \'| grep -v \'127.0.0.1\' | grep -v \'172.17.0.1\' | awk \'{print $2}\')\r\n\r\n                if netstat -nt4 | grep $LOCAL_IP:3080\r\n                then\r\n                        echo \"GNS3 Clients online, No shutdown\"\r\n                else\r\n                        if netstat -nt4 | grep $LOCAL_IP:22\r\n                        then\r\n                                echo \"SSH Clients online, No shutdown\"\r\n                        else\r\n                                /usr/sbin/shutdown now\r\n                        fi\r\n                fi\r\n        fi\r\n        ```\r\n2. 把gns3r.sh添加到root用户的crontab中\r\n    ```\r\n    crontab -u root -e\r\n    */30 * * * * /etc/gns3r.sh\r\n    ```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,91),(42,'设置linux中的PATH','42',1565971200,1583038798,'<!--markdown-->\r\n查看当前的PATH\r\n>echo $PATH\r\n\r\n# Debian10\r\n\r\n### 改变使X11窗口系统环境的PATH\r\n\r\n在55xfce4-session文件前创建一个文件如：/etc/X11/Xsession.d/49add-user-path    \r\n\r\n```\r\n/etc/X11/Xsession.d$ cat 49add-user-path \r\n[ -d \"$HOME/bin\" ] && PATH=\"$HOME/bin:$PATH\"\r\n```\r\n\r\n### 改变其他的环境的PATH\r\n\r\nWhen bash is invoked as an interactive login shell, \r\nor as a non-interactive shell with the `--login` option,\r\nit first reads and executes commands from the file `/etc/profile`,\r\nif that file exists. After reading that file,\r\nit looks for `~/.bash_profile`, `~/.bash_login`, and `~/.profile`,\r\nin that order, and reads and executes commands from the first one that\r\nexists and is readable. The `--noprofile` option may be used when the \r\nshell is started to inhibit this behavior.\r\n\r\nWhen an interactive shell that is not a login shell is started, bash reads\r\nand executes commands from `/etc/bash.bashrc` and `~/.bashrc`, if these files exist.\r\nThis may be inhibited by using the `--norc` option. The `--rcfile` file option will\r\nforce bash to read and execute commands from file instead of `/etc/bash.bashrc` and `~/.bashrc`.\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,94),(43,'TCP/IP路由技术 004-ISIS','43',1566057600,1583038839,'<!--markdown-->\r\nIS-IS的意思是中间系统到中间系统，是由ISO10589定义和解释的。\r\n\r\nISO使用不同的术语来描述与IETF所描述的相同概念实体，一台路由器就是一个中间系统（Intermediate System, IS），而一台主机就是一台端系统（End System，ES）。因此，提供主机与路由器之间通信的协议称为ES-IS协议，而被路由器用来进行相互宣告的协议（路由选择协议）称为IS-IS协议。\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,83),(44,'TCPIP路由技术006 BGP','44',1568476800,1590676137,'<!--markdown--># BGP简介\r\n\r\nBGP的设计目的是连接不受自己管理控制的域中的邻居。通常无法信任这些邻居，必须利用路由策略仔细控制与这些邻居交换的信息。\r\n\r\n入站路由宣告会影响出站流量，出站路由宣告会影响入站流量。\r\n\r\nAS号64512～65535被保留用作私有用途。\r\n\r\n- BGP仅发送单播消息，并且与每个对等体建立一个独立的点到点连接。\r\n\r\n- BGP是一种为其点到点连接使用TCP（端口179）的应用层协议，依靠TCP的内在特性实现会话的维护功能（如确认、重传和排序）。\r\n\r\n- BGP是一种矢量协议，通常称为路径矢量协议，而不是距离矢量协议。\r\n\r\n- BGP路由利用AS_PATH路由属性来描述路径矢量，AS_PATH按序列出了到达目的端的路径所包含的AS号。\r\n\r\n- AS_PATH属性是一种最短路径行列式，如果有多条路径去往同一个目的端，那么AS_PATH中AS号最少的路径就是最短路径。\r\n\r\n- AS_PATH列表中的AS号可以实现环路检测机制。路由器收到BGP路由后，如果发现自己的AS号位于该路由的AS_PATH列表中，那么就认为出现了环路，从而丢弃该路由。\r\n\r\n- 如果路由器与拥有不同AS号的邻居建立了BGP会话，那么就将该BGP会话称为EBGP会话，如果邻居与该路由器的AS号相同，那么就称为IBGP会话，此时分别将这两类邻居称为外部邻居和内部邻居。\r\n\r\n## BGP消息类型\r\n\r\n在建立BGP对等体之前，两个邻居必须执行标准的TCP三次握手进程，并打开到端口179的TCP连接。所有的BGP消息都采用单播方式经TCP连接传递给邻居。\r\n\r\nBGP使用以下4种基本消息类型：\r\n\r\n- Open（打开）消息\r\n\r\n- Keepalive（保持激活）消息\r\n\r\n- Update（更新）消息\r\n\r\n- Notification（通告）消息\r\n\r\n> 还有第五种BGP消息：Route Refresh（路由刷新），但是第五种消息不属于基本的BGP功能，因而可能不是所有的BGP路由器都支持该消息。\r\n\r\n### Open 消息\r\n\r\nTCP会话建立后，两个邻居之间需要发送Open消息，每个邻居都用该消息标识自己并指定BGP操作参数。Open消息包括以下信息。\r\n\r\n- **BGP版本号（BGP version number）**\r\n\r\n  该字段指定发起端正在运行的BGP版本号（2、3或4）。可以在配置会话时利用`neighbor version`命令要求邻居使用指定版本。\r\n\r\n- **自治系统号（Autonomous system number）**\r\n\r\n  该字段表示的是会话发起路由器的AS号，该信息可以确定BGP会话是EBGP会话或IBGP会话。\r\n\r\n- **保持时间（Hold time）**\r\n\r\n  该字段表示路由器在收到Keepalive消息或Update消息之前可以等待的最长时间（以秒为单位）。保持时间必须是0秒（此时必须不发送Keepalive消息）或至少3秒，IOS默认为180秒。如果邻居双方的保持时间不一致，那么将以较短的时间作为双方可以接受的保持时间。可以通过配置语句`timers bgp`来更改整个BGP进程的默认保持时间，也可以通过`neighbor timers`来更改指定邻居或对等体组的默认保持时间。\r\n\r\n- **BGP标识符（BGP identifier）**\r\n\r\n  该字段标识邻居的IPv4地址。IOS确定BGP标识符的过程与OSPF确定路由器ID的过程完全一致：使用数值最大的环回地址；如果环回接口没有配置IP地址，那么就选择数值最大的物理接口IP地址。也可以通过`BGP router-id`命令手工指定BGP标识符。\r\n\r\n- **可选参数（Optional parameters）**\r\n\r\n  该字段用来宣告验证、多协议支持以及路由刷新等可选支持能力。\r\n\r\n### Keepalive 消息\r\n\r\n如果路由器接受邻居发送的Open消息中指定的与参数，那么就响应一条Keepalive消息。此后IOS将默认每60秒发送一条Keepalive消息，或者是按照已协商的保持时间的1/3为周期发送Keepalive消息。\r\n\r\n### Update 消息\r\n\r\nUpdate消息用于宣告可行路由、撤销路由或两者。Update消息包括以下信息。\r\n\r\n- **NLRI（Network Layer Reachability Information，网络层可达性信息）**\r\n\r\n  该字段是一个或多个宣告目的端前缀及其长度的（长度，前缀）二元组。例如，如果宣告的是`206.193.160.0/19`,那么表示长度部分为`/19`，前缀部分为`206.193.160`。\r\n  \r\n- **路径属性（Path Attributes）**\r\n\r\n  该属性提供了允许BGP选择最短路径、检测路由环路并确定路由策略的相关信息。\r\n  \r\n- **撤销路由（Withdrawn Routes）**\r\n\r\n  描述已成为不可达且退出服务的目的端的（长度，前缀）二元组。\r\n  \r\n 虽然NLRI字段可以包含多个前缀，但每条Update消息仅描述单条BGP路径（这是因为路径属性仅描述单条路径，只是该路径可能会通过多个目的端）。\r\n \r\n### Notification 消息\r\n \r\n路由器检测到差错之后会发送Notification消息，并且总要关闭BGP连接。\r\n\r\n## BGP有限状态机\r\n\r\n下面的图和表给出了完整的BGP有限状态机以及触发状态迁移的各种输入事件（IE）\r\n\r\n![BGP有限状态机](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/BGP%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png \"BGP有限状态机\")\r\n\r\n| IE | 描述 |\r\n| ---| ----|\r\n| 1 | BGP启动（Start） |\r\n| 2 | BGP终止（Stop） |\r\n| 3 | BGP传输（Transport）连接打开 |\r\n| 4 | BGP传输（Transport）连接关闭 |\r\n| 5 | BGP传输（Transport）连接打开失败 |\r\n| 6 | BGP传输（Transport）致命性错误 |\r\n| 7 | ConnectRetry（连接重试）定时器到期 |\r\n| 8 | Hold（保持）定时器到期 |\r\n| 9 | Keepalive定时器到期 |\r\n|10 | 接收Open消息 |\r\n|11 | 接收Keepalive消息 |\r\n|12 | 接收Update消息 |\r\n|13 | 接收Notification消息 |\r\n\r\n- **Idle（空闲）状态**\r\n\r\n  BGP总是以Idle状态为起始点，该状态拒绝所有入站连接。如果发生差错，BGP进程将迁移到Idle状态。在第一次迁移到Idle之后，路由器会设置ConnectRetry定时器，在定时器到期时才会重新再启BGP。IOS的初始ConnectRetry时间为120秒，该值不可更改，以后每次ConnectRetry时间都是之前的两倍。\r\n\r\n- **Connect（连接）状态**\r\n  \r\n  该状态下，BGP进程一直等待TCP连接的完成。如果TCP连接建立成功，BGP进程将会向邻居发送Open消息并进入OpenSent（打开发送）状态。如果TCP连接建立不成功，BGP进程将继续侦听由邻居初始化的连接、重置ConnectRety定时器，并迁移到Active（激活）状态。\r\n  \r\n  如果ConnectRetry定时器到期时仍处于Connect状态，则重置定时器，并再次尝试与邻居建立TCP连接，进程也将继续维持在Connect状态，其他输入事件将会让BGP进程迁移到Idle状态。\r\n\r\n- **Active（激活）状态**\r\n  \r\n  该状态下，BGP进程会尝试与邻居初始化TCP连接。如果TCP连接连接建立成功，BGP进程会清除ConnectRetry定时器、完成初始化过程、向其邻居发送Open消息，并迁移到OpenSent（打开发送）状态。IOS默认的保持时间为180秒，可以通过`timers bgp statement`命令设置保持时间。\r\n\r\n- **OpenSent（打开发送）状态**\r\n  \r\n  该状态下，已经发送了Open消息，BGP会一直等待直至侦听到来自邻居的Open消息。接收到Open消息后，会检查该消息的每个字段，如果存在差错，则会发送Notification消息并迁移到Idle状态。\r\n\r\n  如果接收到的Open消息没有差错，则发送Keepalive消息并设置Keepalive定时器，此外还要协商保持时间，以确定一个较小的保持时间值，如果协商后的保持时间为零，则不启动保持定时器和Keepalive定时器。根据对等体的AS号，可以确定对等连接是内部连接还是外部连接，并迁移到OpenConfirm（打开确认）状态。\r\n\r\n  如果收到断开TCP连接的请求，则本地进程将关闭BGP连接、重置ConnectRetry定时器、开始侦听由邻居发起的新连接，并迁移到Active状态。\r\n\r\n- **OpenConfirm（打开确认）状态**\r\n\r\n  该状态下，BGP进程等待Keepalive消息或Notification消息，如果收到的是Keepalive消息，则迁移到Established状态；如果接收到的Notification消息或断开TCP连接请求，则迁移到Idle状态。\r\n\r\n  如果保持定时器到期，或检测到差错，或发生了终止事件，则向邻居发送一条Notification消息、关闭BGP连接，并将状态更改为Idle状态。\r\n\r\n- **Established（建立）状态**\r\n\r\n  该状态下，BGP对待连接已完全建立，对等体之间可以相互交换Update、Keepalive和Notification消息。如果接收到的是Update或Keepalive消息，则重新启动保持定时器（如果协商好的保持时间不是零）。如果接收到的是Notification消息，则迁移到Idle状态。其他事件（启动事件除外，因为该状态会忽略启动事件）将会让BGP进程发送一条Notification消息并迁移到空闲状态。\r\n\r\n## 路径属性\r\n\r\n路径属性有以下4类：\r\n\r\n- **周知强制属性**\r\n  \r\n  ORIGIN, AS_PATH, NEXT_HOP\r\n\r\n- **周知自选属性**\r\n\r\n  LOCAL_PREF, ATOMIC_AGGREGATE\r\n\r\n- **可选传递性属性**\r\n\r\n  AGGREGATOR, COMMUNITY, EXTENDED COMMUNITY, AS4_PATY, AS4_AGGREGATOR\r\n\r\n- **可选非传递性属性**\r\n\r\n  MULTI_EXIT_DISC, ORIGINATOR_ID, CLUSTER_LIST, Multiprotocol Reachable NLRI, Multiprotocol Unreachable NLRI\r\n\r\n周知属性包括强制属性（即必须包含在所有的BGP Update消息中）或自选属性（即可以包含在特定Update消息中，也可以不包含在特定Update消息中）。\r\n\r\n如果可选属性是传递的，那么BGP进程就应该接受该属性中包含的Update消息（即使该进程并不支持该属性），而且应该将该属性传递给对等体。如果可选属性是非传递性的，那么无法识别该属性的BGP进程可以忽略该属性中包含的Update消息，而且不将该路径宣告给其他对等体。简单而言，就是属性可以通过或不可以路由器进行传递。\r\n\r\n### OGRIGIN 属性\r\n\r\nOGRIGN是一种周知强制属性，指定了路由更新的来源。如果BGP存在多条去往同一个目的端的路由时，那么就将OGRIGIN属性作为确定优选路由的要素之一。\r\n\r\n### AS_PATH属性\r\n\r\nAS_PATH属性是一种周知强制属性，该属性利用一串AS号来描述去往由NLRI（Network Layer Reachability Information，网络层可达性信息）指定的目的地的AS间路径或AS级路由。AS发起路由（在其AS内向外部邻居宣告目的地的NLRI）时，会将自己的AS号添加到AS_PATH中。\r\n\r\n仅当Update消息发送给其他AS（也就是EBGP对等体）时，BGP路由器才会在AS_PATH中添加自己的AS号\r\n\r\n### NEXT_HOP属性\r\n\r\n该周知强制属性描述了去往所宣告目的端的路径上的下一跳路由器的IP地址。但是与通常的IGP不同，BGP NEXT_HOP属性所描述的IP地址并不总是邻居路由器的IP地址，其规则如下：\r\n\r\n- 如果宣告路由器与接收路由器位于不同的自治系统中，那么NEXT_HOP是宣告路由器的接口IP地址；\r\n\r\n- 如果宣告路由器与接收路由器位于同一自治系统中（内部对等体），且Update消息的NLRI指向的是同一AS内的目的地，那么NEXT_HOP是发起路由器的IP地址；\r\n\r\n- 如果宣告路由器和接收路由器是内部对等体，且Update消息的NLRI指向的是不同AS内的目的地，那么NEXT_HOP是外部对等体（通过该对等体学习到该路由）的IP地址。\r\n\r\n### 权重\r\n\r\n权重是Cisco的专有BGP路径属性，仅对单台路由器内的路由器有效，无法与其他路由器进行通信。\r\n\r\n## BGP决策进程\r\n\r\n华为规定的决策进程如下:\r\n1. 优选Prefferred_Value属性值最大的路由\r\n2. 优选Local_Preference属性值最大的路由\r\n3. 本地始发的BGP路由优于从其他对等体学习到的路由。其中本地始发的路由类型按优先级从高到低的排列是：`通过手工汇总的方式发布的路由`、`通过自动汇总的方式发布的路由`、`通过network命令发布的路由`以及`通过import-route命令发布的路由`。\r\n4. 优选AS_Path属性值最短的路由\r\n5. 优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP、及Incomplete。\r\n6. 优选MED属性值最小的路由\r\n7. 优选从EBGP对等体学来的路由（EBGP路由优先级高于IBGP路由）。\r\n8. 优选到Next_Hop的IGP度量值最小的路由。\r\n9. 优选Cluster_List最短的路由。\r\n10. 优选Router-ID最小的设备通告的路由。\r\n11. 优选具有最小IP地址（Peer命令所指定的地址）的对等体通告的路由。\r\n\r\n## BGP消息格式\r\n\r\nBGP消息是在TCP报文段中使用TCP端口179进行承载的，最大消息长度为4096个字节，最小长度为19个字节，所有的BGP消息都有一个相同的头部。\r\n\r\n![BGP消息头部](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/BGP%E6%B6%88%E6%81%AF%E5%A4%B4%E9%83%A8.png \"BGP消息头部\")\r\n\r\n- **标志（marker）**：该字段长16字节，用于检测BGP对等体之间的同步丢失情况，并且在支持验证功能的情况下可以进行消息验证。目前所有的BGP实现都将该字段始终设置为全1,在消息头部保留该字段的原因是实现后向兼容性。\r\n\r\n- **长度（length）**：该字段长2个字节，指示消息的全部长度（包括长度），以字节为单位。\r\n\r\n- **类型（type）**：该字段长1字节，指示消息的类型。\r\n\r\n|代码 |类型 |\r\n|---  |---- |\r\n|1    |Open（打开）|\r\n|2    |Update（更新）|\r\n|3    |Notification（通告）|\r\n|4    |Keepalive（保持激活）|\r\n|5    |Route Refresh（路由刷新）|\r\n\r\n## Open消息\r\n\r\nOpen消息是TCP连接建立后发出的第一条消息，如果收到的Open消息是可接受的，那么就发送一条Keepalive消息，以确认该Open消息。确认了Open消息之后，BGP连接就处于Established（建立）状态，可以发送Update、Keepalive以及Notification消息。\r\n\r\n![BGP Open消息的格式](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/BGP%20Open%E6%B6%88%E6%81%AF%E7%9A%84%E6%A0%BC%E5%BC%8F.png \"BGP Open消息的格式\")\r\n\r\nOpen消息的最小长度（包含BGP消息头部）是29个字节。\r\n\r\nBGP Open消息包含以下字段。\r\n\r\n- **版本（Version）**：该字段长1个字节，用于指定发起方运行的BGP版本。\r\n\r\n- **我的自治系统（My Autonomous System）**：该字段长2字节，用于指定发起方的AS号。\r\n\r\n- **BGP标识符（BGP Identifier）**：是发起方的BGP路由ID，除非在BGP配置中指定路由器ID，否则IOS将路由器ID设置为最大的环回接口IP地址，如果没有 配置环回接口，那么就设置为最大的物理接口IP地址。\r\n\r\n- **可选参数长度（Optional Parameters Length）**：该字段长1个字节，表示后面可选参数字段的长度（以字节为单位），如果该字段值为0,那么就表示该消息中无可选参数字段。\r\n\r\n- **可选参数（Optional Parameters）**：该可变字段包含一个可选参数列表，每个参数都由一个长度为1字节的类型字段、一个长为1字节的长度字段以及一个包含参数值的可变长度字段组成。\r\n\r\n## Update消息\r\n\r\n该消息的作用是向对等体宣告一条可行路由或撤销多条不可行路由或者两者。\r\n|BGP Update消息的格式|\r\n|-----------|\r\n|不可行路由的长度（2个字节）|\r\n|被撤消路由（可变长度）   |\r\n|全部路径属性长度（2个字节）|\r\n|路径属性（可变长度）|\r\n|网络层可达性信息（可变长度）|\r\n\r\n- **不可行路由的长度（Unfeasible Routes Length）**：该字段长2个字节，用于指示后面被撤销路由（Withdraw Routes）字段的长度，该字段值为0时表示没有被撤销的路由，且Update消息中无被撤销路由字段。\r\n\r\n- **被撤销路由（Withdraw Routes）**：该可变长度字段包含了一个要退出服务的路由列表，列表中的每条路由都以（长度，前缀）二元组形式加以表示，其中，长度表示前缀的长度，前缀表示被撤销路由的IP地址前缀。如果二元组中的长度部分为0,那么前缀部分将匹配所有路由。\r\n\r\n- **全部路径属性的长度（Total Path Attribute Length）**：该字段长2个字节，用于指示后面的路径属性字段的长度（以字节为单位）。字段值为0时表示Update消息中未包含路径属性的NLRI。\r\n\r\n- **路径属性（Path Attributes）**：该可变长度字段列出了与后面NLRI字段相关联的属性信息，每个路径属性都以可变长度的三元组（属性类型，属性长度，属性值）进行表示，该三元组中的属性类型部分是一个长为2个字节的字段，由4个标记位、4个未用位以及1个属性类型代码组成。下表列出了最常见的一些属性类型代码以及每种属性类型的可能属性值。\r\n\r\n|  |  |  |  |  |  |  |  |              |\r\n|--|--|--|--|--|--|--|--|--------------|\r\n|O |T |P |E |U |U |U |U | 属性类型代码 |\r\n\r\n  O：可选位。0=周知，1=可选。\r\n\r\n  T：转接位。0=非转接，1=转接。\r\n\r\n  P：部分位。0=可选转接属性完整，1=可选转接属性不完整。\r\n\r\n  E：扩展长度位。0=属性长度为一个字节，1=属性长度为两个字节。\r\n\r\n  U：未用\r\n\r\n|类型代码 |属性类型 |属性值代码 |属性值 |\r\n|---------|---------|-----------|-------|\r\n|1        |ORIGIN   |0          |IGP    |\r\n|         |         |1          |EGP    |\r\n|         |         |2          |不完全 |\r\n|2        |AS_PATH  |1          |AS_SET |\r\n|         |         |2          |AS_SEQUENCE|\r\n|         |         |3          |AS_CONFED_SET|\r\n|         |         |4          |AS_CONFED_SEQUENCE|\r\n|3        |NEXT_HOP |0          |下一跳IP地址|\r\n|4        |MULTI_EXIT_DISC|0    |4个字节的MED|\r\n|5        |LOCAL_PREF|0         |4个字节的LOCAL_PREF|\r\n|6        |ATOMIC_AGGREGATER|0  |无     |\r\n|7        |AGGREGATOR|0         |AS号及聚合设备的IP地址|\r\n|8        |COMMUNITY|0          |4个字节团体标识符|\r\n|9        |ORIGINATOR_ID|0      |4个字节的发起方路由器ID|\r\n\r\n\r\n- **网络层可达性信息（Network Layer Reachability Information）**：该可变长度字段包含一个（长度，前缀）二元组，其中，长度部分以比特位为单位表示后面的前缀长度，前缀部分则是NLRI的IP地址前缀。如果长度部分取值为0,那么就表示前缀将匹配所有IP地址。\r\n\r\n## Keepalive消息\r\n\r\nKeepalive消息以保持时间的1/3（但不得小于1秒钟）为周期进行交换，如果协商后的保持时间为0,那么就不发送Keepalive消息。\r\n\r\nKeepalive消息仅包含长度为19个字节的BGP消息头部，不包含其他数据。\r\n\r\n## Notification消息\r\n\r\n路由器检测到差错条件后就会发送该消息。该消息发送后，将立即关闭BGP连接。\r\n\r\n## IBGP对等会话\r\n\r\n同一AS中的每台BGP路由器之间必须建立一条直接的IBGP连接。 \r\n\r\n### 使用Loopback接口建立IBGP邻居\r\n\r\n如果在指定邻居时使用邻居的物理接口IP，那么在物理接口Down掉时，邻居关系就会断开，解决方案是在环回接口之间配置对等会话。\r\n\r\n在环回接口之间配置IBGP对等会话不仅相要为IBGP会话远端指定邻居的环回地址，还必须将本地路由器的环回接口指定为IBGP会话的发起端（默认情况下，出站TCP会话源自出站物理接口地址）。\r\n\r\n## 直连检查与EBGP多跳\r\n\r\n通常情况下，EBGP对等体关系必须基于直连接口建立，因为缺省情况下，EBGP对等体之间发送的BGP协议报文的TTL值为1,这使得这些协议报文只能够被传送一跳。\r\n\r\n绝大多数EBGP会话的标准实践方式是：EBGP会话运行在直连物理接口之间。IOS默认设置通过以下两种措施来确保EBGP对等体之间是直接相连的：\r\n\r\n- 检查已配置邻居的IP地址，以确定该地址属于直连子网；\r\n\r\n- 将发送给外部对等体且包含BGP消息的数据包的TTL值设为1。\r\n\r\n如果外部BGP邻居是直连邻居，但邻居地址不属于本地子网（比如环回口之间建立会话），可以用`neighbor disable-connected-check`禁用IOS的直连检查特性。\r\n\r\n如果两台路由器并未直连，EBGP会话必须穿越一台或多台没有运行BGP的路由器，可以使用`neighbor ebgp-multihop`更改发送给指定邻居的EBGP消息的默认TTL值。这条语句会自动禁用直连检查机制。\r\n\r\n## 管理和保护BGP连接\r\n\r\n`neighbor ttl-security`功能特性会改变接收到的EBGP消息包的可接受TTL值以及发送的BGP消息包的TTL值。比如`neighbor 192.168.1.225 ttl-security hops 1`语句会造成以下两个变化：\r\n\r\n- 从邻居192.168.1.255接收的BGP消息包的TTL值必须是254甚至更大（大于255-1）；\r\n\r\n- 将本地路由器发送给邻居192.168.1.255的BGP消息包的TTL值设置为255。\r\n\r\n# BGP与NLRI（网络层可达性信息）\r\n\r\n与IGP不同，BGP默认并不宣告任何可达性信息。因此，应该始终记着向BGP“注入”前缀。\r\n\r\n## 利用network语句注入前缀\r\n\r\n例：`network 192.168.100.0`，network只能宣告A类，B类，C类前缀，IOS的BGP实现将自动填充相应的8bit，16bit，24bit长度值，如果是其他地址可以使用network mask语句。\r\n\r\nBGP的**network**与在接口上启用协议毫无关系，只是用来指定将要注入本地BGP进程的前缀。如果前缀是通过network语句指定的，那么BGP就会查询IP路由表，如果指定前缀不在表中，那么BGP就不会让前缀进入BGP表中，也就是说，除非路由器拥有去往指定目的地的有效路径，否则BGP不会注入前缀。\r\n\r\n查看BGP表的语句：`show ip bgp`。\r\n\r\n默认情况下，被注入前缀的IGP度量将会成为BGP路由的MED（MULTI_EXIT_DISC）属性，在BGP表中显示为Metric。\r\n\r\n权重（weight）是IOS的专有属性，本地路由器注入前缀的默认权重是32768。\r\n\r\n## 利用network mask语句注入前缀\r\n\r\n例：`network 192.168.172.0 mask 255.255.255.252.0`，此条语句注入了前缀192.168.172.0，掩码255.255.252.0表示使用的前缀长度为22bit。\r\n\r\n## 利用重分发注入前缀\r\n\r\n默认情况是重分发IGP知道的所有路由，如果希望仅宣告部分IGP路由，那么就必须过滤其他路由。\r\n\r\n```\r\nrouter bgp 200\r\n no synchronization\r\n redistribute eigrp 200 router-map ROUTES_IN\r\n neighbor 192.168.1.226 remote-as 100\r\n no auto-summary\r\n\r\naccess-list 1 deny 192.168.1.224\r\naccess-list 1 deny 192.168.1.216\r\naccess-list 1 permit any\r\n\r\nroute-map ROUTES_IN premit 10\r\n match ip address 1\r\n```\r\n上例中增加路由过滤器以阻止注入前缀192.168.1.216/30和192.168.1.224/30，同时允许注入其他前缀。\r\n\r\n被标记了`r`的前缀意味着BGP无法让前缀进入路由表（RIB）。`show ip bgp rib-failure`命令可以提供RIB-failure的详细原因。\r\n\r\n对于没有进入路由表的前缀，BGP默认仍将该前缀宣告给其他对等体。`bgp suppress-inactive`语句可以阻止BGP这样做，即如果BGP表中的表项无法进入本地RIB，那么就不要将该前缀宣告给其他BGP对等体。\r\n\r\n## 在IBGP拓扑结构中管理前缀（向EBGP或IBGP宣告路由的问题）\r\n\r\n路由器向EBGP对等体宣告路由时，会将其出站接口地址添加为该路由的NEXT_HOP属性。默认情况下，路由器路向IBGP对等体宣告路由时，不会更改该路由的NEXT_HOP属性。\r\n\r\n但实际网络中需要路由器将学自EBGP对等体的路由宣告给IBGP对等体时，路由器将NEXT_HOP更改为自己的某个地址，且该地址在本地AS内部已知（路由器ID，也就是环回接口地址）。\r\n\r\n`neighbor next-hop-self`语句可以让路由器将宣告给邻居的所有路由的BGP NEXT_HOP属性都更改为自己的环回地址。\r\n\r\n## IBGP与IGP同步\r\n\r\nIGP同步是早期网络时代的产物，目前已经不再使用该功能，IOS12.2(8)T及以后的版本均默认**禁用同步功能**（**no synchronization**）。\r\n\r\n同步规则的要求如下：\r\n\r\n> 在学自IBGP邻居的路由进入本地路由表之前或者宣告给EBGP对等体之前，必须通过IGP知道该路由。\r\n\r\n\r\n\r\n\r\n\r\n\r\n## IBGP水平分割\r\n当路由器从一个IBGP对等体学习到某条BGP路由时，它将不能再把这条路由通告给任何IBGP对等体，这就是IBGP水平分割规则。为了解决因水平分割而导致的路由传递问题，可以在AS内部建立IBGP的对等体关系全互联模型（此外还有路由反射器和联邦两种解决方案）。\r\n\r\n##### 配置\r\n```\r\n[BGP]# bestroute as-path-ignore //忽略AS-Path对路由优先级的影响\r\n```\r\n\r\n#TODO',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,84),(45,'华为交换机上配置镜像端口','45',1577203200,1583038944,'<!--markdown-->\r\n`[系统视图]observe-port` （undo 删除）\r\n\r\n配置本地观察端口，untag-packet选项可以剥掉镜像报文携带的vlan标签，观察端口在阻塞状态下也可以转发镜像报文。\r\n\r\n`[接口视图]port-mirroring to observe-port` （undo 删除）\r\n\r\n将镜像端口绑定到观察端口，即将镜像端口的报文复制到观察端口。\r\n\r\n为了确保镜像过程中信息不丢失，建议观察端口和镜像端口同类型、同带宽。\r\n\r\n# 查看端口镜像\r\n`display observe-port`\r\n\r\n`display port-mirroring`\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,96),(46,'在Windows上配置FTP服务器','46',1578153600,1583038990,'<!--markdown-->\r\nFTP是一个多端口协议，分别是控制端口和数据端口。\r\n控制端口是TCP 21，数据端口是随机的。\r\n\r\n# 设置被动连接的数据端口\r\n\r\n在服务器主页设置FTP的被动数据端口，如下图，这些端口还需要在防火墙中放行。\r\n\r\n![FTP设置](https://raw.githubusercontent.com/zyywo/zyywo.pic/master/FTP%E8%AE%BE%E7%BD%AE.png)\r\n\r\n防火墙的外部IP是公网IP，被动模式下，服务器会把这个IP和数据通道的端口号一起发送给客户端，客户端访问这个IP和端口来传输数据。\r\n\r\n更改端口号和外部IP后，需要重启服务器才能生效。\r\n\r\n\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,95),(47,'华为交换机清除配置','47',1578585600,1583039118,'<!--markdown-->\r\n\r\n**删除交换机的配置**\r\n  >[用户视图] reset saved-configuration\r\n\r\n**删除接口的配置**\r\n  >[接口视图] clear configuration this\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,81),(48,'cisco交换机配置DNS功能','48',1579017600,1583039167,'<!--markdown--># 交换机开启DNS功能，使交换机能够解析域名\r\n\r\n```\r\nip domain lookup  开启域名解析功能\r\nip name-server {ip-address}  解析域名时用的服务器IP\r\nip domain name {domain-name}  默认的域名\r\n```\r\n## 说明\r\n`ip domain name {domain-name}`  默认的域名，系统会在名称后面加上这个域名，比如，设置`ip domain name lab`，`ping router1`时如果DNS服务器一直对router1没有回应，系统就会尝试解析router1.lab。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,93),(49,'c++数据类型之间的转换','49',1580659200,1583039221,'<!--markdown-->\r\n# string转char*\r\n\r\nstring对象有`data()`和`c_str()`两种方法，data()返回不带`\\0`结尾的字符串，c_str()返回带有`\\0`结尾的字符串。\r\n\r\n另外，也可以调用string对象的`copy()`方法。\r\n\r\n# char*转string\r\n\r\n可以直接把char*字符串赋值给string对象。\r\n\r\n# string转int\r\n\r\n1. 采用标准库中的`atoi()`函数，对于其他类型也都有相应的标准库函数，比如浮点型atof()，long型atol()等。\r\n    ```\r\n    string s = \"123\";\r\n    int a = atoi( s.c_str() );\r\n    ```\r\n\r\n2. 采用sstream头文件中定义的字符串流对象来实现转换。\r\n   ```\r\n   istringstream is(\"12\"); //构造输入字符串流，流的内容初始化为字符串\"12\"\r\n   int i;\r\n   is >> i; //从is流中读入一个int整数存入i中\r\n   ```\r\n\r\n# int转string\r\n\r\n1. 采用标准库中的`to_string()`函数。\r\n    ```\r\n    int i = 12;\r\n    cout << std::to_string(i) >> endl;\r\n    ```\r\n\r\n2. 采用sstream中定义的字符串流对象来实现。\r\n    ```\r\n    ostringstream os; //构造一个输出字符串流，流内容为空\r\n    int i = 12;\r\n    os << i; //向输出字符串流中输出int整数i的内容\r\n    cout << os.str() << endl; //利用字符串流的str方法获取流中的内容\r\n    ```\r\n\r\n\r\n\r\n参考列表：\r\n\r\n[C++中字符串string和整数int的互相转化方式](https://blog.csdn.net/na_beginning/article/details/53576123)\r\n\r\n[C++中string、char *、char[]、const char*的转换](https://blog.csdn.net/hebbely/article/details/79577880)',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,96),(50,'linux中挂载samba文件系统','50',1581004800,1583040096,'<!--markdown--> 1. 安装cifs依赖：\r\n\r\n    `sudo apt install cifs-utils`\r\n\r\n 2. 创建挂载点文件夹\r\n\r\n    `mkdir /home/zyy/openwrt_share`\r\n\r\n 3. 编辑`/etc/fstab`，添加挂载点\r\n\r\n    `//openwrt.lan/share	/home/zyy/openwrt_share	  cifs guest,vers=1.0,uid=zyy,gid=zyy  0	0`\r\n  \r\n    `cifs`是指挂载的文件系统；\r\n\r\n    `guest`选项是匿名登陆；\r\n\r\n    `vers=1`选项是使用的samba版本号；\r\n\r\n    `uid=zyy,gid=zyy`选项是指定文件系统的用户ID和组ID；\r\n\r\n 4. 挂载文件系统\r\n\r\n    `sudo mount -a`\r\n\r\n卸载文件系统可以使用下面的方法：\r\n\r\n`sudo umount /home/zyy/openwrt_share `\r\n\r\n参考：\r\n\r\n[Auto-mount Samba / CIFS shares via fstab on Linux](http://timlehr.com/auto-mount-samba-cifs-shares-via-fstab-on-linux/)',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,99),(51,'在centos7中安装typecho博客','51',1583071800,1585477097,'<!--markdown--># 关闭SELINUX\r\n    \r\n编辑`/etc/selinux/config`文件，设置`SELINUX=disabled`，重启后会永久关闭selinux。\r\n\r\n`setenforce 0`：临时关闭selinux，重启后会再开启\r\n\r\n# 安装http服务器\r\n   \r\n    yum install httpd\r\n\r\n   **开启httpd服务器**    \r\n    systemctl enable httpd\r\n    systemctl start httpd\r\n\r\n# 安装并设置mysql数据库\r\n    yum install mariadb-server mariadb\r\n\r\n编辑`/etc/my.cnf`，add follows within [mysqld] section\r\n   \r\n    [mysqld]\r\n    character-set-server=utf8\r\n    bind-address=127.0.0.1\r\n\r\n**开启mysql服务器**\r\n   \r\n    systemctl enable mariadb\r\n    systemctl start mariadb\r\n\r\n**Initial Settings for MariaDB**\r\n\r\n    mysql_secure_installation\r\n\r\n**使用root用户登陆mysql数据库，创建typecho用的数据库**\r\n\r\n    mysql -u root -p\r\n    \r\n    CREATE DATABASE typecho;  #创建typecho用的数据库\r\n\r\n    SHOW DATABASES;  #验证结果\r\n\r\n# 安装php和用到的组件\r\n\r\n    yum install php php-mbstring php-mysql php-gd curl curl-devel\r\n\r\n# 安装typecho\r\n\r\n   **解压typecho压缩包**\r\n    \r\n    tar -xf 1.1-17.10.30-release.tar.gz\r\n\r\n   **把typecho安装文件夹放到http根目录下**\r\n    \r\n    mv build/* /var/www/html/\r\n\r\n   **修改html目录与了目录的所有者**\r\n\r\n    chown -R apache:apache /var/www/html\r\n\r\n至此结束，访问服务器的80端口就可以了。\r\n\r\n[typecho官网](http://typecho.org/)\r\n\r\n[Typecho主题 - Initial](https://github.com/jielive/initial)',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,118),(52,'VSCode中设置免密/免认证登陆github','52',1585056660,1585056725,'<!--markdown-->编辑项目根目录下的`.git/config`文件，把\r\n```\r\n[remote \"origin\"]\r\nurl = https://www.github.com/user/ck.git\r\n```\r\n中的url替换为：\r\n\r\n`url = https://username:passwd@github.com/user/ck.git`',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,81),(53,'TCP/IP路由技术之005-EIGRP','53',1584797520,1585747451,'<!--markdown-->EIGRP协议包含以下4个部件：\r\n- 依赖于协议的模块；\r\n- 可靠传输协议（RTP）；\r\n- 邻居发现和恢复；\r\n- 扩散更新算法（DUAL）。\r\n\r\n## EIGRP的度量\r\n\r\nmetric=256×{\\[**K1**×BW<sub>IGRP(min)</sub>＋(**K2**×BW<sub>IGRP(min)</sub>)／(256－LOAD)＋**K3**×DLY<sub>IGRP(sum)</sub>]×\\[**K5**／(RELIABILITY＋**K4**)]}\r\n\r\nBW<sub>IGRP(min)</sub>是沿着路由路径到达目的网络的所有出站接口的带宽中的最小值，是用10<sup>7</sup>/BW（带宽）得来的。如果接口的带宽是1544 kbit/s，那么BW<sub>IGRP(min)</sub>=10<sup>7</sup>/1544=6476。\r\n\r\n而DLY<sub>IGRP(sum)</sub>是这条路由路径时延的总和。是以10us作为单位。如果接口的DLY值是50，那么DLY<sub>IGRP(sum)</sub>=DLY/10=50/10=5。\r\n\r\n可靠性和负载是基于5分钟时间常数的指数加权平均计算的，它们每5秒被更新一次。\r\n\r\n系数K1到K5是可配置的加权值，它们的缺省值是：K1=K3=1，K2=K4=K5=0。这些值可以通过下面的命令来更改：\r\n\r\n        metric weights tos K1 K2 K3 K4 K5\r\n\r\ntos的值恒为0。\r\n\r\n使用K1～K5的缺省值，EIGRP的复合度量的计算公式可以简化为：metirc=256×(BW<sub>IGRP(min)</sub>+DLY<sub>IGRP(sum)</sub>)。\r\n\r\n## 依赖于协议的模块\r\n\r\nEIGRP协议实现了IP协议、IPX协议和AppleTalk协议的模块，它可以担负起某一特定协议的路由选择任务。例如，IPX EIGRP模块可以负责在IPX网络上与其他IPX EIGRP进程进行路由信息交换，并且将这些信息传递给DUAL。每个单独模块的通信量被封装在它们各自的网络层协议中。\r\n\r\n## 可靠传输协议\r\n\r\n可靠传输协议（Reliable Transport Protocol，RTP）用来管理EIGRP数据包的发送和接收。可靠的发送是指发送是有保障的而且数据包是有序的发送的。有保障的发送是依赖Cisco公司的“可靠组播（reliable multicast）”这个私有算法来实现的，它使用保留的D类地址224.0.0.10。每一个接收可靠组播数据包的邻居都会发送一个单播的确认数据包。\r\n\r\n有序的发送是通过在每个数据包中包含的两个序列号来实现的。每一个数据包都包含一个由发送该数据包的路由器分配的序列号，这个序列号在每台路由器发送一个新的数据包时递增1.另外，发送路由器会把最近从目的路由器收到的数据包的序列号放在该数据包中。\r\n\r\n在一些实例中，RTP也可以使用不可靠的发送，不需要确认，而且在使用不可靠发送的EIGRP数据包中不包含序列号。\r\n\r\nEIGRP协议使用多种类型的数据包，所有这些数据包都通过IP头部的协议号88来标识。\r\n- **Hello**  用于邻居发现和恢复进程。Hello数据包使用组播方式发送，而且使用不可靠的发送方式。\r\n- **确认(Acknowledgments, ACK）**  是不包含数据的Hello数据包。ACK总是使用单播方式和不可靠的发送方式。\r\n- **更新（Update）** 用于传递路由更新信息。不像RIP协议和IGRP协议的更新，EIGRP协议的这些更新数据包只在必要的时候传递必要的信息，而且仅仅传递给需要路由信息的路由器。当只有某一指定的路由器需要路由更新时，更新数据包就是单播发送的；当有多台路由器需要路由更新时，更新数据包就是组播发送的。更新数据包总是使用可靠的发送方式。\r\n- **查询（Query）和答复（Reply）**  是DUAL有限状态机用来管理它的扩散计算的。查询消息可以使用组播方式或者单播方式发送，而回复消息总是单播方式发送的。查询和回复数据包都是使用可靠的发送方式。\r\n- **请求（Request）**  最初打算提供给路由服务器使用的数据包类型，但是这个应用从来没有实现过，在一些老的文档中可能会提及它们。\r\n \r\n如果任何数据包通过可靠的方式组播出去，而没有从邻居那里收到一个ACK数据包，那么这个数据包就会以单播方式被重新发送给那个没有响应的邻居。如果经过16次这样的单播重传还没有收到一个ACK数据包的话，那么这个邻居就会被宣告为无效。\r\n\r\n在从组播方式切换到单播方式之前等待一个ACK时间可以由组播流计时器（multicast flow timer）指定。后续的单播之间的时间可以由重传超时（Retransmission Timeout，RTO）指定。组播流计时器和重传超时都可以通过平均回程时间（Smooth Round-Trip Time，SRTT）来计算。SRTT是一个用来衡量路由器发送EIGRP数据包到邻居和从邻居那里接收到该数据包的确认所花费的平均时间，以毫秒（ms）为单位。\r\n\r\n## 邻居发现和恢复\r\n\r\n因为EIGRP协议的更新消息是非周期的，因此有一个发现和跟踪邻居的方法是非常重要的。Hello数据包是以组播方式每5s发送一次的，其中减掉一个很小的随机时间用来防止更新的同步。在多点的X.25、帧中继和ATM接口上是以单播方式每60s发送一次的。Hello数据包都是不进行确认的。可以在每个接口上使用命令`ip hello-interval eigrp`更改hello数据包的时间间隔。\r\n\r\n当一台路由器从它的邻居路由器收到一个Hello数据包时，这个数据包将包含一个抑制时间（hold time）。如果抵制计时器超时了，路由器还没收到后续的Hello数据包，那么将宣告这个邻居不可达，并且通知DUAL这个邻居丢失了。在缺省的情况下，抑制时间是Hello时间间隔的3倍，这个缺省值可以在接口上使用命令`ip hold-time eigrp`来更改。\r\n\r\n## 扩散更新算法\r\n\r\n扩散更新算法（Diffusing Update Algorithm，DUAL）是一个收敛算法。\r\n\r\n### DUAL：术语和概念\r\n\r\n1. **邻接（adjacency）**  刚启动时，路由器使用Hello数据包发现它的邻居并标识自己给邻居识别。当邻居被发现时，EIGRP协议将试图和它的邻居形成一个邻接关系。一旦邻接成功建立，路由器就可以从它们的邻居那里接收路由更新消息了。\r\n2. **可行距离（Feasible Distance，FD）**  到达每一个目的地的最小度量将作为该目的地网络的可行距离。\r\n3. **可行性条件（Feasibility Condition，FC）**  可行性条件就是需要满足下面这样的条件——本地路由器的一个邻居路由器所通告的到达一个目的网络的距离是否小于本地路由器到达相同目的网络的可行距离。\r\n4. **可行后继路由器（Feasible Successor，FS**  如果本地路由器的邻居路由器所通告的到达目的网络的距离满足了FC，那么这个邻居就会成为该目的网络的一个可行后继路由器。\r\n5. **后继路由器（successor）**  对于在拓扑结构表中列出的每一个目的网络，将选择拥有最小度量的路由并放置到路由表中。通告这条路由的邻居就成为一个后继路由器（也就是下一跳路由器）。\r\n\r\n### DUAL有限状态机\r\n\r\n当一个EIGRP路由器不执行扩散计算时，每一条路由都处于被动状态（passive state）。路由左边的关键字就是用来指出路由的被动状态的。\r\n\r\n在产生输入事件（input event）的任何时，路由器都会重新评估一条路由的可行后继路由器的列表。一个输入事件可以是：\r\n\r\n- 直连链路的代价发生变化；\r\n- 直连链路的状态（up或down）发生变化；\r\n- 收到一个更新数据包；\r\n- 收到一个查询数据包；\r\n- 收到一个答复数据包。\r\n\r\n路由器重新评估的第一步是，**在本地路由器上执行一个本地计算（local computation）**，对所有的可行后继路由器重新计算到达目的地的距离。可能的结果有下面的一种或多种：\r\n\r\n- 如果拥有最低的度量距离的可行后继路由器和已经存在的后继路由器不同，那么可行后继路由器将成为后继路由器；\r\n- 如果新的度量距离小于FD，那么就更新FD；\r\n- 如果新的度量距离和已经存在的度量距离不同，那么将向所有的邻居发送更新。\r\n\r\n当路由器执行一个本地计算时，路由依然保持被动状态。**如果本地路由器发现了一台可行后继路由器**，那么将发送一个更新消息给它所有的邻居，但不改变路由的状态。\r\n\r\n**如果没有发现任何一台可行后继路由器的话，那么路由器将开始进行扩散计算**，而且路由器的路由状态改变成活动状态（active state），路由的距离和FD也变为不可到达的了。在扩散计算完成和路由的状态返回到被动状态之前，路由器不能：\r\n\r\n- 改变路由的后继路由器；\r\n- 改变正在通告的路由的距离；\r\n- 改变路由的FD；\r\n- 开始进行路由的另一个扩散计算。\r\n \r\n**路由器是通过向它所有的邻居发送查询来开始一个扩散计算的**，查询中包含一个到达目的地的新的本地路由器计算的距离。收到查询后，每一台邻居路由器将执行它自己的本地计算：\r\n\r\n- 如果该邻居拥有到达目的地的一台或多台可行后继路由器，它将发送一个答复给原来发送查询的路由器。答复中将包含这台邻居路由器所计算的它到达目的网络的最小距离。\r\n- 如果一个邻居没有可行后继路由器，它将把路由的状态改变为活动状态，并开始进行扩散计算。\r\n\r\n当本地路由器收到所有发送到邻居路由器的查询的答复时，扩散计算就完成了。在扩散计算开始，会设置一个3分钟的活动计时器，如果计时超时后还没有收到所有的答复，那么这条路由就会被宣告卡在活动状态（Stuck-In-Active，SIA）。这些没有答复的邻居将从邻居表中删除，并且扩散计算认为这个邻居回应了一个无穷大的度量。在活动计时器超时之前，将保持路由状态为活动状态。可以通过`timers active-time`来改变或使其无效。',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,70),(54,'华为的防火墙（firewall）','54',1585478820,1595767650,'<!--markdown-->\r\n华为防火墙上默认的四个安全区域：\r\nuntrust：低级别，安全优先级为5\r\nDMZ：中度级别，安全优先级为50\r\ntrust：较高级别，安全优先级为85\r\nlocal：最高级别，安全优先级为100\r\n\r\nlocal区域指的是设备本身，包括设备的各接口，凡是发给防火墙的都可认为是发向local的，而防火墙始发的数据可以理解为来自local。\r\n\r\n## 安全区域的限制：\r\n防火墙不能有两个相同安全级别的区域\r\n防火墙的一个物理接口只能属于一个安全区域\r\n系统自带的安全区域不能删除\r\n相同区域内的不同接口间的报文不过滤直接转发\r\n一个报文如果进出端口相同，改报文将被丢弃\r\n接口没有加入域之前不能转发报文\r\n\r\n### 区域间（interzone）：\r\n任何两个安全区域都构成一个安全区域间，并具有单独的安全区域间视图，大部分的安全功能配置都是在安全区域间视图下配置。\r\n\r\n### 域间的数据流分两个方向：\r\n**inbound**：数据由低安全级别向高安全级别传输的方向\r\n**outbound**：数据由高安全级别向低安全级别传输的方向\r\n\r\n定义区域间时，两个区域书写的先后顺序不影响方向。\r\n\r\n防火墙的工作模式：\r\n**路由模式**，接口可以配置IP\r\n**透明模式**，接口不能配置IP，可以看做一台二层交换机，可以配置系统管理IP，数据依然会被域间的安全规则检查。\r\n**混合模式**，有的接口工作在路由模式，有的接口工作在透明模式。\r\n\r\n```\r\n创建安全区域\r\n[FW] firewall zone name ISP1\r\n\r\n[FW-zone-ISP1] set priority 20\r\n\r\n进入安全域\r\n[FW] firewall zone trust\r\n\r\n把接口加入安全域\r\n[FW-zone-trust] add interface G0/0/1\r\n\r\n查看防火墙会话表\r\ndisplay firewall session table\r\n\r\n查看设备上安全域的信息\r\ndisplay zone\r\n```\r\n\r\n## Interzone策略\r\n配置域间包过滤策略：\r\n```\r\npolicy interzone trust untrust {inbound | outbound}\r\n  policy0\r\n    policy source 192.168.1.1\r\n    policy destination 202.101.10.1\r\n    policy service service-set st\r\n    action {permit | deny}\r\n  policy1\r\n    ... ... \r\n  policy N\r\n```\r\n\r\n配置缺省域间包过滤策略：\r\n```\r\n开放所有域间缺省包过滤\r\n[FW]firewall packet-filter default permit all\r\n开放trust和untrust域间缺省包过滤\r\n[FW]firewall packet-filter default permit interzone trust untrust\r\n开放trust和untrust域间outbound方向缺省包过滤\r\n[FW]firewall packet-filter default permit interzone trust untrust direction outbound\r\n```\r\n\r\n查看防火墙缺省的域间包过滤策略\r\n`display firewall packet-filter default all`\r\n\r\n\r\nASPF（Application Specific Packet Filter）是指系统为了转发一些多通道协议报文，通过解析报文数据载荷，识别多通道协议自动协商出来的端口号，并自动生成相应的Server-map表项的功能。\r\n\r\nserver-map表是一个通过少量关键元素来记录部分特殊服务连接状态的特殊表项。\r\n\r\nserver-map表用于存放一种映射关系，这种映射关系可以是控制数据协商出来的数据连接的关系，也可以是配置NAT中的地址映射关系，使得外部网络能透过设备主动访问内部网络。可以使用命令：`display firewall server-map`来查看。\r\n\r\n当一个没有会话表项的报文在通过系统的安全性检查之后，系统准备为其查找路由之前，系统会查询server-map表：\r\n\r\n- 对该报文所属连接的状态再次检查和确认；\r\n- 根据Server-map表对报文中一些元素进行转换，\r\n\r\nServer-map只是用于新建通道的建立，通道建立后的报文还是根据会话表来转发。\r\n\r\n```\r\npolicy unterzone trust dmz outbound\r\n policy 0\r\n  policy service service-set ftp\r\n  active permit\r\n\r\nfirewall interzone trust dmz\r\n detect ftp\r\n```',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,63),(55,'debian10中安装GNS3-Server','55',1585840500,1587223324,'<!--markdown-->Install GNS3 server:\r\nsudo dpkg --add-architecture i386\r\nsudo apt update\r\nsudo apt install libc6:i386\r\nsudo apt install libssl-dev:i386\r\nsudo ln -s /lib/i386-linux-gnu/libcrypto.so.1.1 /lib/i386-linux-gnu/libcrypto.so.4\r\n\r\nsudo apt install python3-pip qemu qemu-kvm qemu-utils libvirt-clients libvirt-daemon-system virtinst curl gnupg2\r\n或\r\nsudo apt install python3-pip qemu qemu-kvm qemu-utils libvirt-clients libvirt-daemon-system virtinst apt-transport-https ca-certificates curl gnupg2 software-properties-common\r\n\r\nsudo pip3 install gns3-server\r\nsudo cp init/gns3.service.systemd /etc/systemd/system/gns3.service\r\nsudo systemctl enable gns3\r\n\r\n安装docker-ce,设置国内的Docker hub源:\r\n	参考1：https://docs.docker.com/install/linux/docker-ce/debian/#install-docker-ce-1\r\n	参考2：https://yq.aliyun.com/articles/110806\r\n	参考3：http://mirrors.ustc.edu.cn/help/dockerhub.html\r\n	curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\r\n安装vpc,ubridge，dynamips：\r\n	参考1：https://docs.gns3.com/1QXVIihk7dsOL7Xr7Bmz4zRzTsJ02wklfImGuHwTlaA4/index.html#h.l56h7z55hmxm\r\n	Add the following lines to your /etc/apt/sources.list:\r\n	deb http://ppa.launchpad.net/gns3/ppa/ubuntu bionic main\r\n	deb-src http://ppa.launchpad.net/gns3/ppa/ubuntu bionic main \r\n	Get the GPG key:\r\n	sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F88F6D313016330404F710FC9A2FD067A2E3EF7B\r\n	Refresh your metadata, and ONLY install the following two packages\r\n	sudo apt update\r\n	sudo apt install dynamips ubridge vpcs\r\n	然后为了安全把上面的ppa源注释掉\r\nAdd your user to the following groups:\r\nkvm libvirt docker ubridge wireshark\r\n\r\n如果安装python的psutil包出错：`Python.h：没有那个文件或目录`，可以尝试安装python3-dev解决：`sudo apt install python3-dev`。\r\n',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,70),(56,'生成树（STP）协议','56',1587517380,1587809053,'<!--markdown-->STP为IEEE标准协议，并且有多个协议版本，版本与协议号的对应关系如下：\r\n\r\nCommon Spanning Tree (CST)  =  IEEE 802.1D\r\n\r\nRapid Spanning Tree Protocol (RSTP)  =  IEEE 802.1w\r\n\r\nPer-VLAN Spanning-Tree plus (PVST+)   =   Per-VLAN EEE 802.1D\r\n\r\nRapid PVST+  =  Per-VLAN IEEE 802.1w\r\n\r\nMultiple Spanning Tree Protocol (MSTP)   =    IEEE 802.1s \r\n\r\nSTP在发送数据包测试网络是否有多条链路，是靠发送bridge protocol data units (BPDUs)来完成的，同台交换机发出去的BPDU都被做上了相同的标记，只要任何交换机从多个接口收到相同标记的BPDU，就表示网络中有冗余链路，因此需要STP断开多余链路。BPDU数据包里面有以下信息：\r\n\r\n- 根交换机的bridge ID。\r\n\r\n- 发送交换机的bridge ID 。\r\n\r\n- 到根交换机的Path Cost。\r\n\r\n- 发送接口以及优先级。\r\n\r\n- Hello、forward delay、max-age时间。\r\n\r\n同台交换机发出的BPDU，bridge ID都是一样的，因为是用来标识自己的，其中bridge ID由两部分组成：Bridge优先级和MAC地址，默认优先级为32678。\r\n\r\n交换机上的每个端口也是有优先级的，默认为128，范围为0-255。\r\n \r\n注：**在STP协议中，所有优先级数字越小，表示优先级越高，数字越大，优先级越低。**\r\n\r\n# 选举规则\r\n\r\nSTP在计算网络时，需要在网络中选举出**根交换机（Root）**，**根端口（Root Port）**，以及**指定端口(Designated Port)**，才能保证网络的无环，选举规则分别如下：\r\n\r\n**根交换机（Root）**\r\n\r\n    在同一个三层网络中需要选举，即一个广播域内要选举，并且一个网络中只能选举一台根交换机。Birdge-ID中优先级最高（即数字最小）的为根交换机，优先级范围为0-65535，如果优先级相同，则MAC地址越小的为根交换机。\r\n\r\n**根端口（Root Port）**\r\n\r\n    所有非根交换机都要选举，非根交换机上选举的根端口就是普通交换机去往根交换机的唯一链路，选举规则为 到根交换机的Path Cost值最小的链路，如果多条链路到达根交换机的Path Cost值相同，则选举上一跳交换机Bridge-ID最小的链路，如果是经过的同一台交换机，则上一跳交换机Bridge-ID也是相同的，再选举对端端口优先级最小的链路，如果到达对端的多个端口优先级相同，最后选举交换机 对端端口号码最小的链路。\r\n\r\n**指定端口(Designated Port)**\r\n\r\n     在每个二层网段都要选举，也就是在每个冲突域需要选举，简单地理解为每条连接交换机的物理线路的两个端口中，有一个要被选举为指定端口，每个网段选举指定端口后，就能保证每个网段都有链路能够到达根交换机，选举规则和选举根端口一样，即：到根交换机的Path Cost值最小的链路，如果多条链路到达根交换机的Path Cost值相同，则选举上一跳交换机Bridge-ID最小的链路，如果是经过的同一台交换机，则上一跳交换机Bridge-ID也是相同的，再选举对端端口优先级最小的链路，如果到达对端的多个端口优先级相同，最后选举交换机 对端端口号码最小的链路。\r\n\r\n 在STP选出根交换机，根端口以及指定端口后，其它所有端口全部被Block，为了防止环路，所以Block端口只有在根端口或指定端口失效的时候才有可能被启用。\r\n\r\n#TODO\r\n\r\n 转载自：[China-CCIE STP](http://www.china-ccie.com/ccie/lilun/switching/switching.html#6)',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,60),(57,'IPv6','57',1587801840,1587809097,'<!--markdown-->IPv4采用32位来表示，而IPv6采用128位来表示地址，IPv6将整个地址分为8段，每段之间用冒号隔开，每段的长度为16位。\r\n\r\n#TODO 继续写\r\n\r\n转载自：[China-CCIE](http://www.china-ccie.com/ccie/lilun/IPv6/IPv6.html)',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,61),(58,'TCP/IP路由技术007-路由重分配','58',1587809100,1588682697,'<!--markdown-->当路由器使用路由选择协议通告从其他方式学习到的路由时，路由器将执行重新分配。这里所谓的其他方式可能是**另外一个路由选择协议**、**静态路由**或**直连网络**。例如，路由器可能同时运行OSPF进程和RIP进程。如果设置OSPF进程通告来自RIP进程的路由，这就叫做重新分配RIP。\r\n\r\n# 重新分配的原则\r\n\r\n对重新分配影响最大的协议特性是**度量**和**管理距离**的差异性，以及每种协议的**有类别和无类别**能力。\r\n\r\n接收被重新分配路由的协议必须能够将自己的度量与这些路由关联起来。所以执行重新分配的路由器必须为被重新分配的路由指定**度量**。\r\n\r\n**管理距离**被看作是一个可信度测度，管理距离越小，协议的可信度越高，如果路由器正在运行多个路由选择协议，并从每个协议都学习到一条到达相同目标网络的路由，那么应该选择管理距离最小的路由。\r\n\r\n|路由源 | 管理距离 |\r\n|-------|----------|\r\n|直连接口 | 0 |\r\n|静态路由|1|\r\n|EIGRP汇总路由|5|\r\n|外部BGP|20|\r\n|EIGRP|90|\r\n|IGRP|100|\r\n|OSPF|110|\r\n|IS-IS|115|\r\n|RIP|120|\r\n|EGP|140|\r\n|外部EIGRP|170|\r\n|内部BGP|200|\r\n|未知|255|\r\n\r\n# 配置重新配置\r\n\r\n配置重新分配分为两步：\r\n\r\n1. 在路由选择协议中配置接收重新分配的路由，其中使用命令`redistribute`指定路由源点。\r\n2. 为重新分配的路由指定度量值。\r\n\r\n例如，把OSPF进程1发现的路由向EIGRP进程1重新分配，并指定度量值（带宽，时延，可靠性，负载，MTU）。\r\n```\r\nrouter eigrp 1\r\n redistribute ospf 1 metric 10000 100 255 1 15003\r\n network 172.20.0.0\r\n```\r\n\r\n把EIGRP进程1发现的路由重新分配到OSPF进程1，`metric`部分为每一条被重新分配的路由设置OSPF代价值30.重新分配使路由器成为OSPF域的ASBR。并且被重新分配的路由是作为外部路由进行通告的。`metric-type`指明了外部路由的类型为E1。关键字`subnets`仅当向OSPF重新分配路由时使用，它指明子网细节也被重新分配，没有它，仅重新分配主网地址。\r\n```\r\nrouter ospf 1\r\n redistribute eigrp 1 metric 30 metric-type 1 subnets\r\n network 172.20.11.2 0.0.0.0 area 0\r\n```\r\n\r\n分配度量一种方法是在分配时使用`metric`指定，另一种分配度量的方法是使用`default=metric`命令。\r\n```\r\nrouter ospf 1\r\n redistribute eigrp 1 metric-type 1 subnets\r\n redistribute rip metric-type 1 subnets\r\n default-metric 30\r\n network 172.20.11.2 0.0.0.0 area 0\r\n```\r\n在上面的配置中，对于所有来自EIGRP和RIP的路由，所分配的度量均为OSPF代价30。使用`redistribute`中关键字`metirc`分配度量值优于`default-metric`分配度量值。\r\n\r\n## 重新分配和路由汇总\r\n\r\n命令`summary-address`为OSPF进程指定了一个汇总地址和掩码。任何在指定汇总地址范围内的更精确的地址都会被禁止。注意，此命令仅用在ASBR汇总外部路由；在ABR内部OSPF路由汇总可以通过命令`area range`实现。\r\n```\r\nrouter ospf 1\r\n summary-address 192.168.3.128 255.255.255.128\r\n summary-address 172.16.0.0 255.255.0.0\r\n redistribute eigrp 1 subnets\r\n reidstribute eigrp 2 metric 100 metric-type 1 subnets\r\n default-metric 50\r\n network 192.168.3.33 0.0.0.0 area 0\r\n```\r\n\r\n对于EIGRP的汇总是指定接口的。是在独立的接口下指明。使用命令`ip summary-address eigrp {process-id}`指定汇总地址、掩码和汇总所要通告的EIGRP进程。\r\n\r\n正如OSPF汇总一样，EIGRP的汇总禁止通告汇总范围以内的子网。但与OSPF不一样的是，EIGRP通告的汇总路由没有被标记为外部路由。\r\n\r\n```\r\ninterface FastEthernet0/1\r\n ip address 192.168.3.129 255.255.255.224\r\n ip summary-address eigrp 1 192.168.3.0 255.255.255.128\r\n ip summary-address eigrp 1 172.16.0.0 255.255.0.0\r\n```\r\n\r\n#TODO',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,71),(59,'C++ Primer Plus','59',1588423500,1588682756,'<!--markdown-->复制构造函数：用一个类的实例创建一个新的实例\r\n赋值函数：把一个实例赋值给另一个实例\r\n\r\n#TODO',0,1,NULL,'post','publish',NULL,0,'1','1','1',0,57);
/*!40000 ALTER TABLE `typecho_contents` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_fields`
--

DROP TABLE IF EXISTS `typecho_fields`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_fields` (
  `cid` int(10) unsigned NOT NULL,
  `name` varchar(200) NOT NULL,
  `type` varchar(8) DEFAULT 'str',
  `str_value` text,
  `int_value` int(10) DEFAULT '0',
  `float_value` float DEFAULT '0',
  PRIMARY KEY (`cid`,`name`),
  KEY `int_value` (`int_value`),
  KEY `float_value` (`float_value`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_fields`
--

LOCK TABLES `typecho_fields` WRITE;
/*!40000 ALTER TABLE `typecho_fields` DISABLE KEYS */;
INSERT INTO `typecho_fields` VALUES (2,'thumb','str','',0,0),(1,'thumb','str','',0,0),(1,'catalog','str','1',0,0),(3,'thumb','str','',0,0),(3,'catalog','str','1',0,0),(4,'thumb','str','',0,0),(4,'catalog','str','1',0,0),(5,'thumb','str','',0,0),(5,'catalog','str','1',0,0),(6,'thumb','str','',0,0),(6,'catalog','str','1',0,0),(59,'thumb','str','',0,0),(8,'thumb','str','',0,0),(8,'catalog','str','1',0,0),(9,'thumb','str','',0,0),(9,'catalog','str','1',0,0),(10,'thumb','str','',0,0),(10,'catalog','str','1',0,0),(11,'thumb','str','',0,0),(11,'catalog','str','1',0,0),(12,'thumb','str','',0,0),(12,'catalog','str','1',0,0),(13,'thumb','str','',0,0),(13,'catalog','str','0',0,0),(14,'thumb','str','',0,0),(15,'thumb','str','',0,0),(15,'catalog','str','1',0,0),(16,'thumb','str','',0,0),(16,'catalog','str','1',0,0),(17,'thumb','str','',0,0),(17,'catalog','str','1',0,0),(18,'thumb','str','',0,0),(19,'thumb','str','',0,0),(19,'catalog','str','1',0,0),(20,'thumb','str','',0,0),(20,'catalog','str','1',0,0),(21,'thumb','str','',0,0),(21,'catalog','str','1',0,0),(22,'thumb','str','',0,0),(22,'catalog','str','1',0,0),(23,'thumb','str','',0,0),(23,'catalog','str','1',0,0),(24,'thumb','str','',0,0),(24,'catalog','str','1',0,0),(25,'thumb','str','',0,0),(25,'catalog','str','1',0,0),(26,'thumb','str','',0,0),(26,'catalog','str','1',0,0),(27,'thumb','str','',0,0),(28,'thumb','str','',0,0),(29,'thumb','str','',0,0),(30,'thumb','str','',0,0),(30,'catalog','str','1',0,0),(31,'thumb','str','',0,0),(32,'thumb','str','',0,0),(32,'catalog','str','1',0,0),(33,'thumb','str','',0,0),(33,'catalog','str','1',0,0),(34,'thumb','str','',0,0),(35,'thumb','str','',0,0),(35,'catalog','str','1',0,0),(36,'thumb','str','',0,0),(36,'catalog','str','1',0,0),(37,'thumb','str','',0,0),(38,'thumb','str','',0,0),(39,'thumb','str','',0,0),(40,'thumb','str','',0,0),(40,'catalog','str','1',0,0),(41,'thumb','str','',0,0),(41,'catalog','str','0',0,0),(42,'thumb','str','',0,0),(42,'catalog','str','1',0,0),(43,'thumb','str','',0,0),(43,'catalog','str','1',0,0),(44,'thumb','str','',0,0),(44,'catalog','str','1',0,0),(45,'thumb','str','',0,0),(46,'thumb','str','',0,0),(47,'thumb','str','',0,0),(48,'thumb','str','',0,0),(48,'catalog','str','1',0,0),(49,'thumb','str','',0,0),(49,'catalog','str','1',0,0),(50,'thumb','str','',0,0),(51,'thumb','str','',0,0),(51,'catalog','str','1',0,0),(52,'thumb','str','',0,0),(53,'thumb','str','',0,0),(53,'catalog','str','1',0,0),(54,'thumb','str','',0,0),(54,'catalog','str','1',0,0),(31,'catalog','str','1',0,0),(55,'thumb','str','',0,0),(56,'thumb','str','',0,0),(56,'catalog','str','1',0,0),(57,'thumb','str','',0,0),(57,'catalog','str','1',0,0),(58,'thumb','str','',0,0),(58,'catalog','str','1',0,0);
/*!40000 ALTER TABLE `typecho_fields` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_metas`
--

DROP TABLE IF EXISTS `typecho_metas`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_metas` (
  `mid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(200) DEFAULT NULL,
  `slug` varchar(200) DEFAULT NULL,
  `type` varchar(32) NOT NULL,
  `description` varchar(200) DEFAULT NULL,
  `count` int(10) unsigned DEFAULT '0',
  `order` int(10) unsigned DEFAULT '0',
  `parent` int(10) unsigned DEFAULT '0',
  PRIMARY KEY (`mid`),
  KEY `slug` (`slug`)
) ENGINE=MyISAM AUTO_INCREMENT=19 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_metas`
--

LOCK TABLES `typecho_metas` WRITE;
/*!40000 ALTER TABLE `typecho_metas` DISABLE KEYS */;
INSERT INTO `typecho_metas` VALUES (1,'其他','其他','category','只是一个默认分类',7,6,0),(2,'linux','linux','category',NULL,16,2,0),(3,'windows','windows','category',NULL,5,3,0),(4,'network','network','category',NULL,16,1,0),(5,'huawei','huawei','category',NULL,7,1,4),(6,'cisco','cisco','category',NULL,5,2,4),(7,'linux','linux','tag',NULL,1,0,0),(8,'huawei-network','huawei-network','tag',NULL,1,0,0),(9,'pycharm','pycharm','tag',NULL,1,0,0),(10,'BFD','BFD','tag',NULL,1,0,0),(11,'Python','Python','category',NULL,7,4,0),(12,'C++','C','category',NULL,2,5,0),(13,'vnc','vnc','tag',NULL,1,0,0),(14,'systemd-service','systemd-service','tag',NULL,2,0,0),(15,'wireshark','wireshark','tag',NULL,1,0,0),(16,'excel','excel','tag',NULL,1,0,0),(17,'shell','shell','tag',NULL,2,0,0),(18,'BGP','BGP','tag',NULL,1,0,0);
/*!40000 ALTER TABLE `typecho_metas` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_options`
--

DROP TABLE IF EXISTS `typecho_options`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_options` (
  `name` varchar(32) NOT NULL,
  `user` int(10) unsigned NOT NULL DEFAULT '0',
  `value` text,
  PRIMARY KEY (`name`,`user`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_options`
--

LOCK TABLES `typecho_options` WRITE;
/*!40000 ALTER TABLE `typecho_options` DISABLE KEYS */;
INSERT INTO `typecho_options` VALUES ('theme',0,'initial'),('timezone',0,'28800'),('lang',0,NULL),('charset',0,'UTF-8'),('contentType',0,'text/html'),('gzip',0,'0'),('generator',0,'Typecho 1.1/17.10.30'),('title',0,'笔记本'),('description',0,'从来也不看'),('keywords',0,'typecho,php,blog'),('rewrite',0,'0'),('frontPage',0,'recent'),('frontArchive',0,'0'),('commentsRequireMail',0,'1'),('commentsWhitelist',0,'0'),('commentsRequireURL',0,'0'),('commentsRequireModeration',0,'0'),('plugins',0,'a:0:{}'),('commentDateFormat',0,'F jS, Y \\a\\t h:i a'),('siteUrl',0,'https://www.zhangyongyao.com'),('defaultCategory',0,'1'),('allowRegister',0,'0'),('defaultAllowComment',0,'1'),('defaultAllowPing',0,'1'),('defaultAllowFeed',0,'1'),('pageSize',0,'15'),('postsListSize',0,'10'),('commentsListSize',0,'10'),('commentsHTMLTagAllowed',0,NULL),('postDateFormat',0,'Y-m-d'),('feedFullText',0,'1'),('editorSize',0,'350'),('autoSave',0,'0'),('markdown',0,'1'),('xmlrpcMarkdown',0,'0'),('commentsMaxNestingLevels',0,'5'),('commentsPostTimeout',0,'2592000'),('commentsUrlNofollow',0,'1'),('commentsShowUrl',0,'1'),('commentsMarkdown',0,'0'),('commentsPageBreak',0,'0'),('commentsThreaded',0,'1'),('commentsPageSize',0,'20'),('commentsPageDisplay',0,'last'),('commentsOrder',0,'ASC'),('commentsCheckReferer',0,'1'),('commentsAutoClose',0,'0'),('commentsPostIntervalEnable',0,'1'),('commentsPostInterval',0,'60'),('commentsShowCommentOnly',0,'0'),('commentsAvatar',0,'1'),('commentsAvatarRating',0,'G'),('commentsAntiSpam',0,'1'),('routingTable',0,'a:26:{i:0;a:25:{s:5:\"index\";a:6:{s:3:\"url\";s:1:\"/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:8:\"|^[/]?$|\";s:6:\"format\";s:1:\"/\";s:6:\"params\";a:0:{}}s:7:\"archive\";a:6:{s:3:\"url\";s:6:\"/blog/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:13:\"|^/blog[/]?$|\";s:6:\"format\";s:6:\"/blog/\";s:6:\"params\";a:0:{}}s:2:\"do\";a:6:{s:3:\"url\";s:22:\"/action/[action:alpha]\";s:6:\"widget\";s:9:\"Widget_Do\";s:6:\"action\";s:6:\"action\";s:4:\"regx\";s:32:\"|^/action/([_0-9a-zA-Z-]+)[/]?$|\";s:6:\"format\";s:10:\"/action/%s\";s:6:\"params\";a:1:{i:0;s:6:\"action\";}}s:4:\"post\";a:6:{s:3:\"url\";s:24:\"/archives/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:26:\"|^/archives/([0-9]+)[/]?$|\";s:6:\"format\";s:13:\"/archives/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"cid\";}}s:10:\"attachment\";a:6:{s:3:\"url\";s:26:\"/attachment/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:28:\"|^/attachment/([0-9]+)[/]?$|\";s:6:\"format\";s:15:\"/attachment/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"cid\";}}s:8:\"category\";a:6:{s:3:\"url\";s:17:\"/category/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:25:\"|^/category/([^/]+)[/]?$|\";s:6:\"format\";s:13:\"/category/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}s:3:\"tag\";a:6:{s:3:\"url\";s:12:\"/tag/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:20:\"|^/tag/([^/]+)[/]?$|\";s:6:\"format\";s:8:\"/tag/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}s:6:\"author\";a:6:{s:3:\"url\";s:22:\"/author/[uid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:24:\"|^/author/([0-9]+)[/]?$|\";s:6:\"format\";s:11:\"/author/%s/\";s:6:\"params\";a:1:{i:0;s:3:\"uid\";}}s:6:\"search\";a:6:{s:3:\"url\";s:19:\"/search/[keywords]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:23:\"|^/search/([^/]+)[/]?$|\";s:6:\"format\";s:11:\"/search/%s/\";s:6:\"params\";a:1:{i:0;s:8:\"keywords\";}}s:10:\"index_page\";a:6:{s:3:\"url\";s:21:\"/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:22:\"|^/page/([0-9]+)[/]?$|\";s:6:\"format\";s:9:\"/page/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"page\";}}s:12:\"archive_page\";a:6:{s:3:\"url\";s:26:\"/blog/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:27:\"|^/blog/page/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/blog/page/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"page\";}}s:13:\"category_page\";a:6:{s:3:\"url\";s:32:\"/category/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:34:\"|^/category/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:16:\"/category/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"slug\";i:1;s:4:\"page\";}}s:8:\"tag_page\";a:6:{s:3:\"url\";s:27:\"/tag/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:29:\"|^/tag/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:11:\"/tag/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"slug\";i:1;s:4:\"page\";}}s:11:\"author_page\";a:6:{s:3:\"url\";s:37:\"/author/[uid:digital]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:33:\"|^/author/([0-9]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/author/%s/%s/\";s:6:\"params\";a:2:{i:0;s:3:\"uid\";i:1;s:4:\"page\";}}s:11:\"search_page\";a:6:{s:3:\"url\";s:34:\"/search/[keywords]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:32:\"|^/search/([^/]+)/([0-9]+)[/]?$|\";s:6:\"format\";s:14:\"/search/%s/%s/\";s:6:\"params\";a:2:{i:0;s:8:\"keywords\";i:1;s:4:\"page\";}}s:12:\"archive_year\";a:6:{s:3:\"url\";s:18:\"/[year:digital:4]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:19:\"|^/([0-9]{4})[/]?$|\";s:6:\"format\";s:4:\"/%s/\";s:6:\"params\";a:1:{i:0;s:4:\"year\";}}s:13:\"archive_month\";a:6:{s:3:\"url\";s:36:\"/[year:digital:4]/[month:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:30:\"|^/([0-9]{4})/([0-9]{2})[/]?$|\";s:6:\"format\";s:7:\"/%s/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"year\";i:1;s:5:\"month\";}}s:11:\"archive_day\";a:6:{s:3:\"url\";s:52:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:41:\"|^/([0-9]{4})/([0-9]{2})/([0-9]{2})[/]?$|\";s:6:\"format\";s:10:\"/%s/%s/%s/\";s:6:\"params\";a:3:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:3:\"day\";}}s:17:\"archive_year_page\";a:6:{s:3:\"url\";s:38:\"/[year:digital:4]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:33:\"|^/([0-9]{4})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:12:\"/%s/page/%s/\";s:6:\"params\";a:2:{i:0;s:4:\"year\";i:1;s:4:\"page\";}}s:18:\"archive_month_page\";a:6:{s:3:\"url\";s:56:\"/[year:digital:4]/[month:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:44:\"|^/([0-9]{4})/([0-9]{2})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:15:\"/%s/%s/page/%s/\";s:6:\"params\";a:3:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:4:\"page\";}}s:16:\"archive_day_page\";a:6:{s:3:\"url\";s:72:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:55:\"|^/([0-9]{4})/([0-9]{2})/([0-9]{2})/page/([0-9]+)[/]?$|\";s:6:\"format\";s:18:\"/%s/%s/%s/page/%s/\";s:6:\"params\";a:4:{i:0;s:4:\"year\";i:1;s:5:\"month\";i:2;s:3:\"day\";i:3;s:4:\"page\";}}s:12:\"comment_page\";a:6:{s:3:\"url\";s:53:\"[permalink:string]/comment-page-[commentPage:digital]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:36:\"|^(.+)/comment\\-page\\-([0-9]+)[/]?$|\";s:6:\"format\";s:18:\"%s/comment-page-%s\";s:6:\"params\";a:2:{i:0;s:9:\"permalink\";i:1;s:11:\"commentPage\";}}s:4:\"feed\";a:6:{s:3:\"url\";s:20:\"/feed[feed:string:0]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:4:\"feed\";s:4:\"regx\";s:17:\"|^/feed(.*)[/]?$|\";s:6:\"format\";s:7:\"/feed%s\";s:6:\"params\";a:1:{i:0;s:4:\"feed\";}}s:8:\"feedback\";a:6:{s:3:\"url\";s:31:\"[permalink:string]/[type:alpha]\";s:6:\"widget\";s:15:\"Widget_Feedback\";s:6:\"action\";s:6:\"action\";s:4:\"regx\";s:29:\"|^(.+)/([_0-9a-zA-Z-]+)[/]?$|\";s:6:\"format\";s:5:\"%s/%s\";s:6:\"params\";a:2:{i:0;s:9:\"permalink\";i:1;s:4:\"type\";}}s:4:\"page\";a:6:{s:3:\"url\";s:12:\"/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";s:4:\"regx\";s:22:\"|^/([^/]+)\\.html[/]?$|\";s:6:\"format\";s:8:\"/%s.html\";s:6:\"params\";a:1:{i:0;s:4:\"slug\";}}}s:5:\"index\";a:3:{s:3:\"url\";s:1:\"/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:7:\"archive\";a:3:{s:3:\"url\";s:6:\"/blog/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:2:\"do\";a:3:{s:3:\"url\";s:22:\"/action/[action:alpha]\";s:6:\"widget\";s:9:\"Widget_Do\";s:6:\"action\";s:6:\"action\";}s:4:\"post\";a:3:{s:3:\"url\";s:24:\"/archives/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:10:\"attachment\";a:3:{s:3:\"url\";s:26:\"/attachment/[cid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:8:\"category\";a:3:{s:3:\"url\";s:17:\"/category/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:3:\"tag\";a:3:{s:3:\"url\";s:12:\"/tag/[slug]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:6:\"author\";a:3:{s:3:\"url\";s:22:\"/author/[uid:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:6:\"search\";a:3:{s:3:\"url\";s:19:\"/search/[keywords]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:10:\"index_page\";a:3:{s:3:\"url\";s:21:\"/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"archive_page\";a:3:{s:3:\"url\";s:26:\"/blog/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:13:\"category_page\";a:3:{s:3:\"url\";s:32:\"/category/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:8:\"tag_page\";a:3:{s:3:\"url\";s:27:\"/tag/[slug]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"author_page\";a:3:{s:3:\"url\";s:37:\"/author/[uid:digital]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"search_page\";a:3:{s:3:\"url\";s:34:\"/search/[keywords]/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"archive_year\";a:3:{s:3:\"url\";s:18:\"/[year:digital:4]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:13:\"archive_month\";a:3:{s:3:\"url\";s:36:\"/[year:digital:4]/[month:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:11:\"archive_day\";a:3:{s:3:\"url\";s:52:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:17:\"archive_year_page\";a:3:{s:3:\"url\";s:38:\"/[year:digital:4]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:18:\"archive_month_page\";a:3:{s:3:\"url\";s:56:\"/[year:digital:4]/[month:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:16:\"archive_day_page\";a:3:{s:3:\"url\";s:72:\"/[year:digital:4]/[month:digital:2]/[day:digital:2]/page/[page:digital]/\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:12:\"comment_page\";a:3:{s:3:\"url\";s:53:\"[permalink:string]/comment-page-[commentPage:digital]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}s:4:\"feed\";a:3:{s:3:\"url\";s:20:\"/feed[feed:string:0]\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:4:\"feed\";}s:8:\"feedback\";a:3:{s:3:\"url\";s:31:\"[permalink:string]/[type:alpha]\";s:6:\"widget\";s:15:\"Widget_Feedback\";s:6:\"action\";s:6:\"action\";}s:4:\"page\";a:3:{s:3:\"url\";s:12:\"/[slug].html\";s:6:\"widget\";s:14:\"Widget_Archive\";s:6:\"action\";s:6:\"render\";}}'),('actionTable',0,'a:0:{}'),('panelTable',0,'a:0:{}'),('attachmentTypes',0,'@image@'),('secret',0,'LG58fM7VNVF$w%ruLoZOOzL2fx6guqB5'),('installed',0,'1'),('allowXmlRpc',0,'2'),('theme:initial',0,'a:32:{s:7:\"logoUrl\";s:0:\"\";s:8:\"subTitle\";s:0:\"\";s:11:\"customTitle\";s:0:\"\";s:7:\"favicon\";s:0:\"\";s:12:\"cjcdnAddress\";s:0:\"\";s:13:\"AttUrlReplace\";s:0:\"\";s:6:\"Navset\";a:2:{i:0;s:12:\"ShowCategory\";i:1;s:8:\"ShowPage\";}s:12:\"CategoryText\";s:0:\"\";s:8:\"PageText\";s:0:\"\";s:11:\"Breadcrumbs\";a:3:{i:0;s:8:\"Postshow\";i:1;s:4:\"Text\";i:2;s:8:\"Pageshow\";}s:6:\"WeChat\";s:0:\"\";s:6:\"Alipay\";s:0:\"\";s:11:\"LicenseInfo\";s:0:\"\";s:9:\"HeadFixed\";s:1:\"0\";s:12:\"SidebarFixed\";s:1:\"0\";s:5:\"cjCDN\";s:2:\"bc\";s:11:\"GravatarUrl\";s:1:\"0\";s:12:\"compressHtml\";s:1:\"0\";s:10:\"PjaxOption\";s:1:\"0\";s:8:\"AjaxLoad\";s:1:\"0\";s:9:\"scrollTop\";s:1:\"1\";s:8:\"MusicSet\";s:1:\"0\";s:8:\"MusicUrl\";s:0:\"\";s:8:\"MusicVol\";s:0:\"\";s:15:\"InsideLinksIcon\";s:1:\"0\";s:14:\"IndexLinksSort\";s:0:\"\";s:15:\"InsideLinksSort\";s:0:\"\";s:9:\"ShowLinks\";N;s:11:\"ShowWhisper\";N;s:12:\"sidebarBlock\";a:2:{i:0;s:7:\"ShowTag\";i:1;s:11:\"ShowArchive\";}s:8:\"ICPbeian\";s:0:\"\";s:13:\"CustomContent\";s:0:\"\";}');
/*!40000 ALTER TABLE `typecho_options` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_relationships`
--

DROP TABLE IF EXISTS `typecho_relationships`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_relationships` (
  `cid` int(10) unsigned NOT NULL,
  `mid` int(10) unsigned NOT NULL,
  PRIMARY KEY (`cid`,`mid`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_relationships`
--

LOCK TABLES `typecho_relationships` WRITE;
/*!40000 ALTER TABLE `typecho_relationships` DISABLE KEYS */;
INSERT INTO `typecho_relationships` VALUES (1,2),(1,7),(3,5),(4,3),(5,1),(5,9),(6,5),(6,8),(6,10),(8,3),(9,11),(10,2),(10,3),(11,4),(12,11),(13,1),(14,11),(15,2),(16,11),(17,5),(18,4),(19,2),(20,2),(20,13),(20,14),(21,5),(22,11),(23,11),(24,4),(25,1),(25,4),(25,15),(26,4),(27,4),(28,11),(29,2),(30,2),(31,1),(31,3),(31,16),(32,4),(33,4),(34,2),(34,17),(35,6),(36,4),(37,2),(38,1),(39,2),(40,2),(40,14),(41,2),(41,17),(42,2),(43,4),(44,4),(44,18),(45,5),(46,3),(47,5),(48,6),(49,12),(50,2),(51,2),(52,1),(53,4),(53,6),(54,4),(54,5),(55,1),(55,2),(55,4),(56,4),(56,6),(57,4),(58,6),(59,12);
/*!40000 ALTER TABLE `typecho_relationships` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `typecho_users`
--

DROP TABLE IF EXISTS `typecho_users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `typecho_users` (
  `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(32) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  `mail` varchar(200) DEFAULT NULL,
  `url` varchar(200) DEFAULT NULL,
  `screenName` varchar(32) DEFAULT NULL,
  `created` int(10) unsigned DEFAULT '0',
  `activated` int(10) unsigned DEFAULT '0',
  `logged` int(10) unsigned DEFAULT '0',
  `group` varchar(16) DEFAULT 'visitor',
  `authCode` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`uid`),
  UNIQUE KEY `name` (`name`),
  UNIQUE KEY `mail` (`mail`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `typecho_users`
--

LOCK TABLES `typecho_users` WRITE;
/*!40000 ALTER TABLE `typecho_users` DISABLE KEYS */;
INSERT INTO `typecho_users` VALUES (1,'admin','$P$B1Jj8O6v.mkKnYVTn5.toPoQbQbawY/','zyywo1@yeah.net','https://www.zhangyongyao.com','张紧轮',1582904845,1597584514,1596949519,'administrator','4da64456fe64a05b34fee1d7132b2cdb');
/*!40000 ALTER TABLE `typecho_users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-08-16 21:48:59
